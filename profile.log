FUNCTION  neocomplcache#complete_check()
Called 136 times
Total time:   0.016161
 Self time:   0.000770

count  total (s)   self (s)
  136   0.016010   0.000619   return neocomplcache#helper#complete_check()

FUNCTION  neosnippet#variables#current_neosnippet()
Called 68 times
Total time:   0.000746
 Self time:   0.000746

count  total (s)   self (s)
   68              0.000214   if !exists('b:neosnippet')
                                let b:neosnippet = { 'snippets' : {}, 'selected_text' : '', 'target' : '', 'trigger' : 0, 'optional_tabstop' : 0,}
                              endif
                            
   68              0.000088   return b:neosnippet

FUNCTION  neocomplcache#util#uniq()
Called 156 times
Total time:   0.008485
 Self time:   0.001409

count  total (s)   self (s)
  156   0.008359   0.001283   return call(s:List.uniq, a:000)

FUNCTION  airline#parts#filetype()
Called 138 times
Total time:   0.000484
 Self time:   0.000484

count  total (s)   self (s)
  138              0.000383   return &filetype

FUNCTION  neocomplcache#is_plugin_locked()
Called 460 times
Total time:   0.013314
 Self time:   0.006899

count  total (s)   self (s)
  460   0.004234   0.001662   if !neocomplcache#is_enabled()
                                return 1
                              endif
                            
  460   0.005934   0.002091   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
  460              0.001460   return get(neocomplcache.lock_sources, a:source_name, 0)

FUNCTION  neocomplcache#handler#_on_moved_i()
Called 23 times
Total time:   0.005100
 Self time:   0.000358

count  total (s)   self (s)
                              " Get cursor word.
   23   0.004613   0.000147   let cur_text = neocomplcache#get_cur_text(1)
                            
   23   0.000424   0.000148   call s:close_preview_window()

FUNCTION  <SNR>228_HighlightTag()
Called 2 times
Total time:   0.000331
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000004     let tagline = 0
                            
    2              0.000005     let force = a:0 > 0 ? a:1 : 0
                            
    2              0.000002     if a:0 > 1
                                    let tag = s:GetNearbyTag(1, 0, a:2)
                                else
    2   0.000286   0.000009         let tag = s:GetNearbyTag(1, 0)
    2              0.000002     endif
    2              0.000003     if !empty(tag)
    2              0.000003         let tagline = tag.tline
    2              0.000001     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    2              0.000004     if !force && tagline == s:last_highlight_tline
    2              0.000002         return
                                else
                                    let s:last_highlight_tline = tagline
                                endif
                            
                                let tagbarwinnr = bufwinnr('__Tagbar__')
                                if tagbarwinnr == -1
                                    return
                                endif
                                let prevwinnr = winnr()
                                call s:goto_win(tagbarwinnr)
                            
                                match none
                            
                                " No tag above cursor position so don't do anything
                                if tagline == 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                if g:tagbar_autoshowtag == 1 || a:openfolds
                                    call s:OpenParents(tag)
                                endif
                            
                                " Check whether the tag is inside a closed fold and highlight the parent
                                " instead in that case
                                let tagline = tag.getClosedParentTline()
                            
                                " Parent tag line number is invalid, better don't do anything
                                if tagline <= 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                " Go to the line containing the tag
                                execute tagline
                            
                                " Make sure the tag is visible in the window
                                call winline()
                            
                                let foldpat = '[' . s:icon_open . s:icon_closed . ' ]'
                                let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\zs[^( ]\+\ze/'
                                call s:debug("Highlight pattern: '" . pattern . "'")
                                if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                    execute 'match TagbarHighlight ' . pattern
                                else
                                    execute 'match Search ' . pattern
                                endif
                            
                            
                                if a:0 <= 1 " no line explicitly given, so assume we were in the file window
                                    call s:goto_win(prevwinnr)
                                endif
                            
                                redraw

FUNCTION  neocomplcache#handler#_do_auto_complete()
Called 23 times
Total time:   0.189735
 Self time:   0.003982

count  total (s)   self (s)
   23   0.002322   0.000117   if s:check_in_do_auto_complete()
                                return
                              endif
                            
   23   0.000300   0.000118   let neocomplcache = neocomplcache#get_current_neocomplcache()
   23              0.000050   let neocomplcache.skipped = 0
   23              0.000049   let neocomplcache.event = a:event
                            
   23   0.003691   0.000112   let cur_text = neocomplcache#get_cur_text(1)
                            
   23              0.000038   if g:neocomplcache_enable_debug
                                echomsg 'cur_text = ' . cur_text
                              endif
                            
                              " Prevent infinity loop.
   23   0.001084   0.000133   if s:is_skip_auto_complete(cur_text)
                                " Make cache.
                                if cur_text =~ '^\s*$\|\s\+$'
                                  if neocomplcache#is_enabled_source('buffer_complete')
                                    " Caching current cache line.
                                    call neocomplcache#sources#buffer_complete#caching_current_line()
                                  endif
                                  if neocomplcache#is_enabled_source('member_complete')
                                    " Caching current cache line.
                                    call neocomplcache#sources#member_complete#caching_current_line()
                                  endif
                                endif
                            
                                if g:neocomplcache_enable_debug
                                  echomsg 'Skipped.'
                                endif
                            
                                call neocomplcache#helper#clear_result()
                                return
                              endif
                            
   23              0.000053   let neocomplcache.old_cur_text = cur_text
                            
   23   0.014963   0.000141   if neocomplcache#helper#is_omni_complete(cur_text)
                                call feedkeys("\<Plug>(neocomplcache_start_omni_complete)")
                                return
                              endif
                            
                              " Check multibyte input or eskk.
   23   0.001640   0.000293   if neocomplcache#is_eskk_enabled() || neocomplcache#is_multibyte_input(cur_text)
                                if g:neocomplcache_enable_debug
                                  echomsg 'Skipped.'
                                endif
                            
                                return
                              endif
                            
                              " Check complete position.
   23   0.160961   0.000334   let complete_results = neocomplcache#complete#_set_results_pos(cur_text)
   23              0.000048   if empty(complete_results)
                                if g:neocomplcache_enable_debug
                                  echomsg 'Skipped.'
                                endif
                            
                                return
                              endif
                            
   23              0.000101   let &l:completefunc = 'neocomplcache#complete#auto_complete'
                            
   23   0.001213   0.000166   if neocomplcache#is_prefetch()
                                " Do prefetch.
                                let neocomplcache.complete_results = neocomplcache#complete#_get_results(cur_text)
                            
                                if empty(neocomplcache.complete_results)
                                  if g:neocomplcache_enable_debug
                                    echomsg 'Skipped.'
                                  endif
                            
                                  " Skip completion.
                                  let &l:completefunc = 'neocomplcache#complete#manual_complete'
                                  call neocomplcache#helper#clear_result()
                                  return
                                endif
                              endif
                            
   23   0.001122   0.000129   call s:save_foldinfo()
                            
                              " Set options.
   23              0.000129   set completeopt-=menu
   23              0.000053   set completeopt-=longest
   23              0.000043   set completeopt+=menuone
                            
                              " Start auto complete.
   23              0.000336   call feedkeys(&l:formatoptions !~ 'a' ? "\<Plug>(neocomplcache_start_auto_complete)": "\<Plug>(neocomplcache_start_auto_complete_no_select)")

FUNCTION  <SNR>214_ProcessByLine()
Called 69 times
Total time:   0.020659
 Self time:   0.000583

count  total (s)   self (s)
   69   0.020614   0.000538   call s:PreviewCSSColor(getline(a:w))

FUNCTION  neosnippet#helpers#get_filetype()
Called 68 times
Total time:   0.001756
 Self time:   0.001756

count  total (s)   self (s)
   68              0.000255   if !exists('s:exists_context_filetype')
                                " context_filetype.vim installation check.
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
   68              0.000314   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
   68              0.000128   if context_filetype == ''
                                let context_filetype = 'nothing'
                              endif
                            
   68              0.000111   return context_filetype

FUNCTION  bufferline#refresh_status()
Called 138 times
Total time:   0.183267
 Self time:   0.004013

count  total (s)   self (s)
  138              0.000353   if g:bufferline_solo_highlight
                                if g:bufferline_status_info.count == 1
                                  exec printf('highlight! link %s %s', g:bufferline_active_highlight, g:bufferline_inactive_highlight)
                                else
                                  exec printf('highlight! link %s NONE', g:bufferline_active_highlight)
                                endif
                              endif
  138   0.180570   0.001316   call bufferline#get_echo_string()
  138              0.000179   return ''

FUNCTION  neocomplcache#complete#_get_complete_pos()
Called 25 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
   25              0.000052   if empty(a:sources)
   21              0.000021     return -1
                              endif
                            
    4              0.000040   return min([col('.')] + map(copy(a:sources), 'v:val.neocomplcache__context.complete_pos'))

FUNCTION  neocomplcache#init#_sources()
Called 46 times
Total time:   0.001017
 Self time:   0.001017

count  total (s)   self (s)
   46              0.000148   if !exists('s:loaded_source_files')
                                " Initialize.
                                let s:loaded_source_files = {}
                                let s:loaded_all_sources = 0
                                let s:runtimepath_save = ''
                              endif
                            
                              " Initialize sources table.
   46              0.000450   if s:loaded_all_sources && &runtimepath ==# s:runtimepath_save
   46              0.000040     return
                              endif
                            
                              let runtimepath_save = neocomplcache#util#split_rtp(s:runtimepath_save)
                              let runtimepath = neocomplcache#util#join_rtp( filter(neocomplcache#util#split_rtp(), 'index(runtimepath_save, v:val) < 0'))
                              let sources = neocomplcache#variables#get_sources()
                            
                              for name in filter(copy(a:names), '!has_key(sources, v:val)')
                                " Search autoload.
                                for source_name in map(split(globpath(runtimepath, 'autoload/neocomplcache/sources/*.vim'), '\n'), "fnamemodify(v:val, ':t:r')")
                                  if has_key(s:loaded_source_files, source_name)
                                    continue
                                  endif
                            
                                  let s:loaded_source_files[source_name] = 1
                            
                                  let source = neocomplcache#sources#{source_name}#define()
                                  if empty(source)
                                    " Ignore.
                                    continue
                                  endif
                            
                                  call neocomplcache#define_source(source)
                                endfor
                            
                                if name == '_'
                                  let s:loaded_all_sources = 1
                                  let s:runtimepath_save = &runtimepath
                                endif
                              endfor

FUNCTION  <SNR>54_JumpOut()
Called 2 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000008     let column = col('.') - 1
    2              0.000006     let line = getline('.')
    2              0.000027     let mcol = match(line[column :], a:char)
    2              0.000004     if a:pair == ''
    2              0.000004         let pcol = -1
    2              0.000002     else
                                    let pcol = match(line[column :], a:pair)
                                endif
    2              0.000004     if a:char != '' && mcol >= 0 && mcol <= pcol
                                    "Yeah, this is ugly but vim actually requires each to be special
                                    "cased to avoid screen flashes/not doing the right thing.
                                    " echom len(line).' '.(column+mcol)
                                    if line[column] == a:char
                                        return "\<Right>"
                                    elseif column+mcol == len(line)-1
                                        return "\<C-O>A"
                                    else
                                        return "\<C-O>f".a:char."\<Right>"
                                    endif
                                else
    2              0.000004         return a:char
                                endif

FUNCTION  neocomplcache#get_context_filetype()
Called 810 times
Total time:   0.030575
 Self time:   0.017749

count  total (s)   self (s)
  810   0.008775   0.003084   if !neocomplcache#is_enabled()
                                return &filetype
                              endif
                            
  810   0.011133   0.003998   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
  810              0.003392   if a:0 != 0 || mode() !=# 'i' || neocomplcache.context_filetype == ''
                                call neocomplcache#context_filetype#set()
                              endif
                            
  810              0.001274   return neocomplcache.context_filetype

FUNCTION  neocomplcache#context_filetype#get()
Called 96 times
Total time:   0.009188
 Self time:   0.008365

count  total (s)   self (s)
                              " Default.
   96              0.000228   let filetype = a:filetype
   96              0.000162   if filetype == ''
                                let filetype = 'nothing'
                              endif
                            
                              " Default range.
   96   0.001300   0.000477   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
   96              0.000369   let pos = [line('.'), col('.')]
   96              0.000456   for include in get(g:neocomplcache_context_filetype_lists, filetype, [])
                                let start_backward = searchpos(include.start, 'bneW')
                            
                                " Check pos > start.
                                if start_backward[0] == 0 || s:compare_pos(start_backward, pos) > 0
                                  continue
                                endif
                            
                                let end_pattern = include.end
                                if end_pattern =~ '\\1'
                                  let match_list = matchlist(getline(start_backward[0]), include.start)
                                  let end_pattern = substitute(end_pattern, '\\1', '\=match_list[1]', 'g')
                                endif
                                let end_forward = searchpos(end_pattern, 'nW')
                                if end_forward[0] == 0
                                  let end_forward = [line('$'), len(getline('$'))+1]
                                endif
                            
                                " Check end > pos.
                                if s:compare_pos(pos, end_forward) > 0
                                  continue
                                endif
                            
                                let end_backward = searchpos(end_pattern, 'bnW')
                            
                                " Check start <= end.
                                if s:compare_pos(start_backward, end_backward) < 0
                                  continue
                                endif
                            
                                if start_backward[1] == len(getline(start_backward[0]))
                                  " Next line.
                                  let start_backward[0] += 1
                                  let start_backward[1] = 1
                                endif
                                if end_forward[1] == 1
                                  " Previous line.
                                  let end_forward[0] -= 1
                                  let end_forward[1] = len(getline(end_forward[0]))
                                endif
                            
                                let neocomplcache.context_filetype_range = [ start_backward, end_forward ]
                                return include.filetype
                              endfor
                            
   96              0.000137   return filetype

FUNCTION  airline#extensions#tagbar#currenttag()
Called 138 times
Total time:   0.015429
 Self time:   0.002809

count  total (s)   self (s)
  138              0.000606   if get(w:, 'airline_active', 0)
  138              0.000491     if s:airline_tagbar_last_lookup_time != localtime()
   23   0.012837   0.000217       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   23              0.000077       let s:airline_tagbar_last_lookup_time = localtime()
   23              0.000015     endif
  138              0.000347     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  airline#check_mode()
Called 138 times
Total time:   0.119088
 Self time:   0.016558

count  total (s)   self (s)
  138              0.000996   let context = s:contexts[a:winnr]
                            
  138              0.000654   if get(w:, 'airline_active', 1)
  138              0.000557     let l:m = mode()
  138              0.000377     if l:m ==# "i"
   42              0.000125       let l:mode = ['insert']
   42              0.000071     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                else
   96              0.000330       let l:mode = ['normal']
   96              0.000122     endif
  138              0.000978     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  138              0.000134   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
  138              0.000647   if g:airline_detect_modified && &modified
  116              0.001391     call add(l:mode, 'modified')
  116              0.000119   endif
                            
  138              0.000346   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  138              0.000345   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
  138              0.000855   let mode_string = join(l:mode)
  138              0.000819   if get(w:, 'airline_lastmode', '') != mode_string
    5   0.000524   0.000050     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    5   0.102121   0.000065     call airline#highlighter#highlight(l:mode)
    5              0.000020     let w:airline_lastmode = mode_string
    5              0.000005   endif
                            
  138              0.000198   return ''

FUNCTION  <SNR>228_IsValidFile()
Called 2 times
Total time:   0.000275
 Self time:   0.000260

count  total (s)   self (s)
    2   0.000027   0.000012     call s:debug('Checking if file is valid [' . a:fname . ']')
                            
    2              0.000005     if a:fname == '' || a:ftype == ''
                                    call s:debug('Empty filename or type')
                                    return 0
                                endif
                            
    2              0.000082     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call s:debug('File not readable')
                                    return 0
                                endif
                            
    2              0.000087     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call s:debug('File is marked as ignored')
                                    return 0
                                endif
                            
    2              0.000004     if &previewwindow
                                    call s:debug('In preview window')
                                    return 0
                                endif
                            
    2              0.000006     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call s:debug('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
    2              0.000003     return 1

FUNCTION  neocomplcache#is_multibyte_input()
Called 23 times
Total time:   0.001217
 Self time:   0.001217

count  total (s)   self (s)
   23              0.001192   return (exists('b:skk_on') && b:skk_on)     || char2nr(split(a:cur_text, '\zs')[-1]) > 0x80

FUNCTION  neocomplcache#helper#get_syn_name()
Called 138 times
Total time:   0.078017
 Self time:   0.078017

count  total (s)   self (s)
  138              0.077852   return len(getline('.')) < 200 ? synIDattr(synIDtrans(synID(line('.'), mode() ==# 'i' ?          col('.')-1 : col('.'), a:is_trans)), 'name') : ''

FUNCTION  <SNR>265_check_in_do_auto_complete()
Called 23 times
Total time:   0.002205
 Self time:   0.001394

count  total (s)   self (s)
   23   0.000894   0.000083   if neocomplcache#is_locked()
                                return 1
                              endif
                            
   23              0.000061   if &l:completefunc == ''
                                let &l:completefunc = 'neocomplcache#complete#manual_complete'
                              endif
                            
                              " Detect completefunc.
   23              0.000183   if &l:completefunc !~# '^neocomplcache#'
                                if &l:buftype =~ 'nofile'
                                  return 1
                                endif
                            
                                if g:neocomplcache_force_overwrite_completefunc
                                  " Set completefunc.
                                  let &l:completefunc = 'neocomplcache#complete#manual_complete'
                                else
                                  " Warning.
                                  redir => output
                                  99verbose setl completefunc?
                                  redir END
                                  call neocomplcache#print_error(output)
                                  call neocomplcache#print_error( 'Another plugin set completefunc! Disabled neocomplcache.')
                                  NeoComplCacheLock
                                  return 1
                                endif
                              endif
                            
                              " Detect AutoComplPop.
   23              0.000082   if exists('g:acp_enableAtStartup') && g:acp_enableAtStartup
                                call neocomplcache#print_error( 'Detected enabled AutoComplPop! Disabled neocomplcache.')
                                NeoComplCacheLock
                                return 1
                              endif

FUNCTION  neocomplcache#helper#keyword_escape()
Called 330 times
Total time:   0.045290
 Self time:   0.031991

count  total (s)   self (s)
                              " Fuzzy completion.
  330              0.001143   let keyword_len = len(a:complete_str)
  330   0.014076   0.002318   let keyword_escape = s:keyword_escape(a:complete_str)
  330              0.001220   if g:neocomplcache_enable_fuzzy_completion && (g:neocomplcache_fuzzy_completion_start_length          <= keyword_len && keyword_len < 20)
                                let pattern = keyword_len >= 8 ? '\0\\w*' : '\\%(\0\\w*\\|\U\0\E\\l*\\)'
                            
                                let start = g:neocomplcache_fuzzy_completion_start_length
                                if start <= 1
                                  let keyword_escape = substitute(keyword_escape, '\w', pattern, 'g')
                                elseif keyword_len < 8
                                  let keyword_escape = keyword_escape[: start - 2] . substitute(keyword_escape[start-1 :], '\w', pattern, 'g')
                                else
                                  let keyword_escape = keyword_escape[: 3] . substitute(keyword_escape[4:12], '\w',   pattern, 'g') . keyword_escape[13:]
                                endif
                              else
                                " Underbar completion. "{{{
  330              0.003278     if g:neocomplcache_enable_underbar_completion && keyword_escape =~ '[^_]_\|^_'
   12              0.000136       let keyword_escape = substitute(keyword_escape, '\%(^\|[^_]\)\zs_', '[^_]*_', 'g')
   12              0.000010     endif
  330              0.003212     if g:neocomplcache_enable_underbar_completion && '-' =~ '\k' && keyword_escape =~ '[^-]-'
                                  let keyword_escape = substitute(keyword_escape, '[^-]\zs-', '[^-]*-', 'g')
                                endif
                                "}}}
                                " Camel case completion. "{{{
  330              0.002519     if g:neocomplcache_enable_camel_case_completion && keyword_escape =~ '\u\?\U*'
  330              0.004622       let keyword_escape = substitute(keyword_escape, '\u\?\zs\U*', '\\%(\0\\l*\\|\U\0\E\\u*_\\?\\)', 'g')
  330              0.000285     endif
                                "}}}
  330              0.000234   endif
                            
  330   0.003522   0.001981   call neocomplcache#print_debug(keyword_escape)
  330              0.000532   return keyword_escape

FUNCTION  airline#util#append()
Called 414 times
Total time:   0.007142
 Self time:   0.007142

count  total (s)   self (s)
  414              0.001327   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  414              0.002327   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  414              0.001982   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>119_Highlight_Matching_Pair()
Called 130 times
Total time:   0.028135
 Self time:   0.028135

count  total (s)   self (s)
                              " Remove any previous match.
  130              0.001116   if exists('w:paren_hl_on') && w:paren_hl_on
    4              0.000072     3match none
    4              0.000015     let w:paren_hl_on = 0
    4              0.000005   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  130              0.001183   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  130              0.000784   let c_lnum = line('.')
  130              0.000652   let c_col = col('.')
  130              0.000342   let before = 0
                            
  130              0.001208   let c = getline(c_lnum)[c_col - 1]
  130              0.004439   let plist = split(&matchpairs, '.\zs[:,]')
  130              0.000820   let i = index(plist, c)
  130              0.000286   if i < 0
                                " not found, in Insert mode try character before the cursor
  127              0.000907     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   44              0.000076       let before = 1
   44              0.000172       let c = getline(c_lnum)[c_col - 2]
   44              0.000121       let i = index(plist, c)
   44              0.000037     endif
  127              0.000224     if i < 0
                                  " not found, nothing to do
  126              0.000207       return
                                endif
    1              0.000000   endif
                            
                              " Figure out the arguments for searchpairpos().
    4              0.000008   if i % 2 == 0
    2              0.000005     let s_flags = 'nW'
    2              0.000009     let c2 = plist[i + 1]
    2              0.000003   else
    2              0.000005     let s_flags = 'nbW'
    2              0.000005     let c2 = c
    2              0.000013     let c = plist[i - 1]
    2              0.000001   endif
    4              0.000012   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    4              0.000010   if before > 0
    1              0.000005     let save_cursor = winsaveview()
    1              0.000004     call cursor(c_lnum, c_col - before)
    1              0.000001   endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    4              0.000025   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
    4              0.006090   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    4              0.000023   let stoplinebottom = line('w$')
    4              0.000021   let stoplinetop = line('w0')
    4              0.000009   if i % 2 == 0
    2              0.000007     let stopline = stoplinebottom
    2              0.000002   else
    2              0.000005     let stopline = stoplinetop
    2              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    4              0.000025   if mode() == 'i' || mode() == 'R'
    1              0.000006     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    1              0.000001   else
    3              0.000035     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    3              0.000003   endif
    4              0.000010   try
    4              0.003206     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    4              0.000015   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    4              0.000007   if before > 0
    1              0.000009     call winrestview(save_cursor)
    1              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    4              0.000020   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    4              0.000660     exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    4              0.000028     let w:paren_hl_on = 1
    4              0.000006   endif

FUNCTION  neocomplcache#helper#get_cur_text()
Called 52 times
Total time:   0.007809
 Self time:   0.005461

count  total (s)   self (s)
   52              0.000652   let cur_text = (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))
                            
   52              0.000798   if cur_text =~ '^.\{-}\ze\S\+$'
   50              0.000580     let complete_str = matchstr(cur_text, '\S\+$')
   50              0.000646     let cur_text = matchstr(cur_text, '^.\{-}\ze\S\+$')
   50              0.000046   else
    2              0.000004     let complete_str = ''
    2              0.000001   endif
                            
   52   0.000730   0.000290   let neocomplcache = neocomplcache#get_current_neocomplcache()
   52              0.000119   if neocomplcache.event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
   52   0.002166   0.000258   let filetype = neocomplcache#get_context_filetype()
   52              0.000347   let wildcard = get(g:neocomplcache_wildcard_characters, filetype, get(g:neocomplcache_wildcard_characters, '_', '*'))
   52              0.000182   if g:neocomplcache_enable_wildcard && wildcard !=# '*' && len(wildcard) == 1
                                " Substitute wildcard character.
                                while 1
                                  let index = stridx(complete_str, wildcard)
                                  if index <= 0
                                    break
                                  endif
                            
                                  let complete_str = complete_str[: index-1] . '*' . complete_str[index+1: ]
                                endwhile
                              endif
                            
   52              0.000190   let neocomplcache.cur_text = cur_text . complete_str
                            
                              " Save cur_text.
   52              0.000077   return neocomplcache.cur_text

FUNCTION  neocomplcache#get_completion_length()
Called 274 times
Total time:   0.012042
 Self time:   0.006779

count  total (s)   self (s)
  274   0.003166   0.001220   let sources = neocomplcache#variables#get_sources()
  274              0.000825   if !has_key(sources, a:source_name)
                                " Unknown.
                                return -1
                              endif
                            
  274   0.005214   0.001897   if neocomplcache#is_auto_complete() && neocomplcache#get_current_neocomplcache().completion_length >= 0
                                return neocomplcache#get_current_neocomplcache().completion_length
                              else
  274              0.000734     return sources[a:source_name].min_pattern_length
                              endif

FUNCTION  <SNR>246_word_caching()
Called 24 times
Total time:   0.008419
 Self time:   0.000580

count  total (s)   self (s)
                              " Initialize source.
   24   0.007984   0.000145   call s:initialize_source(a:srcname)
                            
   24              0.000080   let source = s:buffer_sources[a:srcname]
                            
   24              0.000248   if !filereadable(source.path) || getbufvar(a:srcname, '&buftype') =~ 'nofile'
   24              0.000021     return
                              endif
                            
                              let source.cache_name = neocomplcache#cache#async_load_from_file(     'buffer_cache', source.path,     source.keyword_pattern, 'B')
                              let source.cached_time = localtime()
                              let source.end_line = len(getbufline(a:srcname, 1, '$'))
                              let s:async_dictionary_list[source.path] = [{ 'filename' : source.path, 'cachename' : source.cache_name, }]

FUNCTION  neocomplcache#mappings#popup_post()
Called 23 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
   23              0.000129   return  !pumvisible() ? "" : g:neocomplcache_enable_auto_select ? "\<C-p>\<Down>" : "\<C-p>"

FUNCTION  neocomplcache#cache#check_cache()
Called 44 times
Total time:   0.001285
 Self time:   0.001041

count  total (s)   self (s)
   44              0.000176   let is_string = get(a:000, 0, 0)
                            
                              " Caching.
   44              0.000166   if !has_key(a:keyword_list_dictionary, a:key)
                                let a:keyword_list_dictionary[a:key] = {}
                              endif
   44   0.000693   0.000449   return neocomplcache#cache#check_cache_list( a:cache_dir, a:key, a:async_cache_dictionary, a:keyword_list_dictionary[a:key], is_string)

FUNCTION  469()
Called 22 times
Total time:   0.061808
 Self time:   0.001468

count  total (s)   self (s)
   22   0.061440   0.001100   let list = s:keyword_filter(neosnippet#helpers#get_snippets(), a:cur_keyword_str)
                            
   22              0.000048   for snippet in list
                                let snippet.dup = 1
                            
                                let snippet.menu = neosnippet#util#strwidthpart( snippet.menu_template, winwidth(0)/3)
                                if g:neosnippet#enable_preview
                                  let snippet.info = snippet.snip
                                endif
                              endfor
                            
   22              0.000026   return list

FUNCTION  airline#themes#get_highlight()
Called 234 times
Total time:   0.044434
 Self time:   0.001809

count  total (s)   self (s)
  234   0.044323   0.001698   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  neosnippet#util#get_cur_text()
Called 68 times
Total time:   0.000982
 Self time:   0.000982

count  total (s)   self (s)
   68              0.000901   return (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))

FUNCTION  <SNR>246_check_cache()
Called 2 times
Total time:   0.000380
 Self time:   0.000380

count  total (s)   self (s)
    2              0.000010   let release_accessd_time = localtime() - g:neocomplcache_release_cache_time
                            
   32              0.000090   for [key, source] in items(s:buffer_sources)
                                " Check deleted buffer and access time.
   30              0.000132     if !bufloaded(str2nr(key)) || (source.accessed_time > 0 && source.accessed_time < release_accessd_time)
                                  " Remove item.
    4              0.000016       call remove(s:buffer_sources, key)
    4              0.000004     endif
   30              0.000022   endfor

FUNCTION  <SNR>253_get_omni_funcs()
Called 46 times
Total time:   0.012580
 Self time:   0.009610

count  total (s)   self (s)
   46              0.000098   let funcs = []
  138              0.000897   for ft in insert(split(a:filetype, '\.'), '_')
   92              0.000298     if has_key(g:neocomplcache_omni_functions, ft)
                                  let omnifuncs = (type(g:neocomplcache_omni_functions[ft]) == type([])) ? g:neocomplcache_omni_functions[ft] : [g:neocomplcache_omni_functions[ft]]
                                else
   92              0.000248       let omnifuncs = [&l:omnifunc]
   92              0.000083     endif
                            
  184              0.000275     for omnifunc in omnifuncs
   92   0.001136   0.000510       if neocomplcache#check_invalid_omnifunc(omnifunc)
                                    " omnifunc is irregal.
                                    continue
                                  endif
                            
   92              0.000356       if get(g:neocomplcache_omni_patterns, omnifunc, '') != ''
                                    let pattern = g:neocomplcache_omni_patterns[omnifunc]
                                  elseif get(g:neocomplcache_omni_patterns, ft, '') != ''
   46              0.000137         let pattern = g:neocomplcache_omni_patterns[ft]
   46              0.000031       else
   46              0.000072         let pattern = ''
   46              0.000032       endif
                            
   92              0.000145       if pattern == ''
   46              0.000089         continue
                                  endif
                            
   46              0.000269       call add(funcs, [omnifunc, pattern])
   46              0.000041     endfor
   92              0.000081   endfor
                            
   46   0.002803   0.000459   return s:List.uniq(funcs)

FUNCTION  neocomplcache#cache#encode_name()
Called 24 times
Total time:   0.003719
 Self time:   0.000377

count  total (s)   self (s)
                              " Check cache directory.
   24   0.001553   0.000164   let cache_dir = neocomplcache#get_temporary_directory() . '/' . a:cache_dir
   24   0.002124   0.000171   return s:Cache.getfilename(cache_dir, a:filename)

FUNCTION  neocomplcache#variables#get_filters()
Called 4 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    4              0.000011   if !exists('s:filters')
                                let s:filters = {}
                              endif
    4              0.000004   return s:filters

FUNCTION  neocomplcache#helper#complete_check()
Called 136 times
Total time:   0.015391
 Self time:   0.007223

count  total (s)   self (s)
  136   0.001994   0.000707   let neocomplcache = neocomplcache#get_current_neocomplcache()
  136              0.000220   if g:neocomplcache_enable_debug
                                echomsg split(reltimestr(reltime(neocomplcache.start_time)))[0]
                              endif
  136   0.011044   0.004163   let ret = (!neocomplcache#is_prefetch() && complete_check()) || (neocomplcache#is_auto_complete()     && g:neocomplcache_skip_auto_completion_time != ''     && split(reltimestr(reltime(neocomplcache.start_time)))[0] >          g:neocomplcache_skip_auto_completion_time)
  136              0.000164   if ret
                                let neocomplcache = neocomplcache#get_current_neocomplcache()
                                let neocomplcache.skipped = 1
                            
                                redraw
                                echo 'Skipped.'
                              endif
                            
  136              0.000134   return ret

FUNCTION  neocomplcache#complete#auto_complete()
Called 25 times
Total time:   0.905495
 Self time:   0.000257

count  total (s)   self (s)
   25   0.905468   0.000230   return neocomplcache#complete#manual_complete(a:findstart, a:base)

FUNCTION  neocomplcache#helper#is_omni_complete()
Called 46 times
Total time:   0.030273
 Self time:   0.003218

count  total (s)   self (s)
                              " Check eskk complete length.
   46   0.000436   0.000221   if neocomplcache#is_eskk_enabled() && exists('g:eskk#start_completion_length')
                                if !neocomplcache#is_eskk_convertion(a:cur_text) || !neocomplcache#is_multibyte_input(a:cur_text)
                                  return 0
                                endif
                            
                                let complete_pos = call(&l:omnifunc, [1, ''])
                                let complete_str = a:cur_text[complete_pos :]
                                return neocomplcache#util#mb_strlen(complete_str) >= g:eskk#start_completion_length
                              endif
                            
   46   0.001790   0.000214   let filetype = neocomplcache#get_context_filetype()
   46              0.000227   let omnifunc = get(g:neocomplcache_omni_functions, filetype, &l:omnifunc)
                            
   46   0.000639   0.000236   if neocomplcache#check_invalid_omnifunc(omnifunc)
                                return 0
                              endif
                            
   46   0.025171   0.000310   let syn_name = neocomplcache#helper#get_syn_name(1)
   46              0.000183   if syn_name ==# 'Comment' || syn_name ==# 'String'
                                " Skip omni_complete in string literal.
                                return 0
                              endif
                            
   46              0.000190   if has_key(g:neocomplcache_force_omni_patterns, omnifunc)
                                let pattern = g:neocomplcache_force_omni_patterns[omnifunc]
                              elseif filetype != '' && get(g:neocomplcache_force_omni_patterns, filetype, '') != ''
                                let pattern = g:neocomplcache_force_omni_patterns[filetype]
                              else
   46              0.000048     return 0
                              endif
                            
                              if a:cur_text !~# '\%(' . pattern . '\m\)$'
                                return 0
                              endif
                            
                              " Set omnifunc.
                              let &omnifunc = omnifunc
                            
                              return 1

FUNCTION  neocomplcache#unpack_dictionary()
Called 66 times
Total time:   0.102641
 Self time:   0.102641

count  total (s)   self (s)
   66              0.000121   let ret = []
   66              0.002735   let values = values(a:dict)
 8934              0.008419   for l in (type(values) == type([]) ? values : values(values))
 8868              0.080336     let ret += (type(l) == type([])) ? copy(l) : values(l)
 8868              0.007711   endfor
                            
   66              0.000111   return ret

FUNCTION  airline#parts#iminsert()
Called 138 times
Total time:   0.001293
 Self time:   0.001293

count  total (s)   self (s)
  138              0.000481   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  138              0.000159   return ''

FUNCTION  neocomplcache#get_keyword_pattern()
Called 306 times
Total time:   0.029117
 Self time:   0.003572

count  total (s)   self (s)
  306              0.001321   let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                            
  306   0.027387   0.001842   return neocomplcache#helper#unite_patterns( g:neocomplcache_keyword_patterns, filetype)

FUNCTION  <SNR>246_caching_current_buffer()
Called 4 times
Total time:   0.029183
 Self time:   0.029134

count  total (s)   self (s)
                              " Current line caching.
                            
    4   0.000095   0.000046   if !s:exists_current_source()
                                call s:word_caching(bufnr('%'))
                              endif
                            
    4              0.000031   let source = s:buffer_sources[bufnr('%')]
    4              0.000023   let keyword_pattern = source.keyword_pattern
    4              0.000026   let keyword_pattern2 = '^\%('.keyword_pattern.'\m\)'
    4              0.000016   let keywords = source.keyword_cache
                            
    4              0.000014   let completion_length = 2
    4              0.000108   let line = join(getline(a:start, a:end))
    4              0.000143   let match = match(line, keyword_pattern)
  323              0.000717   while match >= 0 "{{{
  319              0.007310     let match_str = matchstr(line, keyword_pattern2, match)
                            
                                " Ignore too short keyword.
  319              0.001724     if len(match_str) >= g:neocomplcache_min_keyword_length "{{{
                                  " Check dup.
  249              0.001985       let key = tolower(match_str[: completion_length-1])
  249              0.001128       if !has_key(keywords, key)
    1              0.000017         let keywords[key] = {}
    1              0.000003       endif
  249              0.001280       if !has_key(keywords[key], match_str)
                                    " Append list.
    1              0.000013         let keywords[key][match_str] = match_str
    1              0.000011         let source.frequencies[match_str] = 30
    1              0.000003       endif
  249              0.000340     endif"}}}
                            
                                " Next match.
  319              0.007947     let match = match(line, keyword_pattern, match + len(match_str))
  319              0.000722   endwhile"}}}

FUNCTION  <SNR>279_compare()
Called 30 times
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
   30              0.000142   let diff = (get(a:i2, 'rank', 0) - get(a:i1, 'rank', 0))
   30              0.000105   return (diff != 0) ? diff : (a:i1.word ># a:i2.word) ? 1 : -1

FUNCTION  neocomplcache#helper#unite_patterns()
Called 310 times
Total time:   0.025897
 Self time:   0.025897

count  total (s)   self (s)
  310              0.000690   let keyword_patterns = []
  310              0.000613   let dup_check = {}
                            
                              " Composite filetype.
  620              0.002272   for ft in split(a:filetype, '\.')
  310              0.001375     if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
  282              0.000727       let dup_check[ft] = 1
  282              0.001545       call add(keyword_patterns, a:pattern_var[ft])
  282              0.000247     endif
                            
                                " Same filetype.
  310              0.001791     if exists('g:neocomplcache_same_filetype_lists') && has_key(g:neocomplcache_same_filetype_lists, ft)
                                  for ft in split(g:neocomplcache_same_filetype_lists[ft], ',')
                                    if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                      let dup_check[ft] = 1
                                      call add(keyword_patterns, a:pattern_var[ft])
                                    endif
                                  endfor
                                endif
  310              0.000254   endfor
                            
  310              0.000621   if empty(keyword_patterns)
   28              0.000216     let default = get(a:pattern_var, '_', get(a:pattern_var, 'default', ''))
   28              0.000048     if default != ''
   24              0.000210       call add(keyword_patterns, default)
   24              0.000017     endif
   28              0.000020   endif
                            
  310              0.000983   return join(keyword_patterns, '\m\|')

FUNCTION  neocomplcache#within_comment()
Called 46 times
Total time:   0.027719
 Self time:   0.000303

count  total (s)   self (s)
   46   0.027688   0.000272   return neocomplcache#helper#get_syn_name(1) ==# 'Comment'

FUNCTION  <SNR>64_refresh()
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000012   let &updatetime = a:updatetime
    2              0.000025   autocmd bufferline CursorHold * call s:cursorhold_callback()

FUNCTION  neocomplcache#check_invalid_omnifunc()
Called 138 times
Total time:   0.001029
 Self time:   0.001029

count  total (s)   self (s)
  138              0.000947   return a:omnifunc == '' || (a:omnifunc !~ '#' && !exists('*' . a:omnifunc))

FUNCTION  bufferline#get_echo_string()
Called 142 times
Total time:   0.183639
 Self time:   0.016185

count  total (s)   self (s)
                              " check for special cases like help files
  142              0.000938   let current = bufnr('%')
  142              0.000580   if !bufexists(current) || !buflisted(current)
                                return bufname('%')
                              endif
                            
  142   0.168680   0.001226   let names = s:generate_names()
  142              0.000278   let line = ''
 1278              0.001566   for val in names
 1136              0.003470     let line .= val[1]
 1136              0.001114   endfor
                            
  142              0.002453   let index = match(line, '\V'.g:bufferline_status_info.current)
  142              0.000623   let g:bufferline_status_info.count = len(names)
  142              0.000667   let g:bufferline_status_info.before = strpart(line, 0, index)
  142              0.000965   let g:bufferline_status_info.after = strpart(line, index + len(g:bufferline_status_info.current))
  142              0.000222   return line

FUNCTION  <SNR>94_repo_dir()
Called 4 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    4              0.000036   return join([self.git_dir]+a:000,'/')

FUNCTION  neosnippet#helpers#get_snippets()
Called 68 times
Total time:   0.092516
 Self time:   0.070862

count  total (s)   self (s)
   68   0.000828   0.000307   call neosnippet#init#check()
                            
   68   0.001081   0.000335   let neosnippet = neosnippet#variables#current_neosnippet()
   68              0.000245   let snippets = copy(neosnippet.snippets)
  204   0.012153   0.000885   for filetype in s:get_sources_filetypes(neosnippet#helpers#get_filetype())
  136   0.005761   0.000815     call neosnippet#commands#_make_cache(filetype)
  136   0.010378   0.009455     call extend(snippets, neosnippet#variables#snippets()[filetype], 'keep')
  136              0.000146   endfor
                            
   68   0.001361   0.000379   let cur_text = neosnippet#util#get_cur_text()
                            
   68              0.000136   if mode() ==# 'i'
                                " Special filters.
   68   0.002668   0.000400     if !s:is_beginning_of_line(cur_text)
    5              0.001609       call filter(snippets, '!v:val.options.head')
    5              0.000005     endif
   68              0.000054   endif
                            
   68              0.054772   call filter(snippets, "cur_text =~# get(v:val, 'regexp', '')")
                            
   68              0.000141   return snippets

FUNCTION  470()
Called 2 times
Total time:   0.000394
 Self time:   0.000091

count  total (s)   self (s)
    2   0.000392   0.000089   return sort(a:context.candidates, 's:compare')

FUNCTION  <SNR>136_get_hunks()
Called 138 times
Total time:   0.007797
 Self time:   0.004063

count  total (s)   self (s)
  138              0.000553   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let s:source_func = 's:get_hunks_changes'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
  138   0.005036   0.001302   return {s:source_func}()

FUNCTION  neocomplcache#helper#get_source_filetypes()
Called 156 times
Total time:   0.017948
 Self time:   0.009463

count  total (s)   self (s)
  156              0.000619   let filetype = (a:filetype == '') ? 'nothing' : a:filetype
                            
  156              0.000316   let filetype_dict = {}
                            
  156              0.000372   let filetypes = [filetype]
  156              0.000548   if filetype =~ '\.'
                                if exists('g:neocomplcache_ignore_composite_filetype_lists') && has_key(g:neocomplcache_ignore_composite_filetype_lists, filetype)
                                  let filetypes = [g:neocomplcache_ignore_composite_filetype_lists[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
                              endif
                            
  156              0.000596   if exists('g:neocomplcache_same_filetype_lists')
  312              0.000707     for ft in copy(filetypes)
  156              0.001619       let filetypes += split(get(g:neocomplcache_same_filetype_lists, ft, get(g:neocomplcache_same_filetype_lists, '_', '')), ',')
  156              0.000169     endfor
  156              0.000116   endif
                            
  156   0.009473   0.000988   return neocomplcache#util#uniq(filetypes)

FUNCTION  321()
Called 138 times
Total time:   0.001928
 Self time:   0.001928

count  total (s)   self (s)
  138              0.000967     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
  138              0.000227     return b:syntastic_loclist

FUNCTION  airline#highlighter#get_highlight()
Called 234 times
Total time:   0.042625
 Self time:   0.015276

count  total (s)   self (s)
  234   0.013687   0.001278   let fg = s:get_syn(a:group, 'fg')
  234   0.013196   0.001450   let bg = s:get_syn(a:group, 'bg')
  234              0.010063   let reverse = has('gui_running') ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  234   0.005375   0.002181   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  neocomplcache#is_prefetch()
Called 203 times
Total time:   0.009421
 Self time:   0.002072

count  total (s)   self (s)
  203   0.009247   0.001898   return !neocomplcache#is_locked() && (g:neocomplcache_enable_prefetch || &l:formatoptions =~# 'a')

FUNCTION  <SNR>54_CloseStackPop()
Called 2 times
Total time:   0.000491
 Self time:   0.000398

count  total (s)   self (s)
                                "echom "pop"
    2              0.000018     if(a:char == '')
    2              0.000006         silent! pclose
    2              0.000004     endif
    2              0.000059     echom len(s:closeStack)
    2              0.000007     if len(s:closeStack) == 0
                                    return <SID>JumpOut(a:char, a:pair)
                                endif
    2              0.000016     let column = col('.') - 1
    2              0.000008     let line = getline('.')
    2              0.000004     let popped = ''
    2              0.000004     let lastpop = ''
                                "echom join(s:closeStack,'').' || '.lastpop
    2              0.000015     let oldStack = s:closeStack[:]
   16              0.000064     while len(s:closeStack) > 0 && ((lastpop == '' && popped == '') || lastpop != a:char)
   14              0.000061         let lastpop = remove(s:closeStack,0)
   14              0.000030         let popped .= lastpop
                                    "echom join(s:closeStack,'').' || '.lastpop.' || '.popped
   14              0.000014     endwhile
    2              0.000004     if lastpop != a:char
    2              0.000005         let s:closeStack = oldStack
    2   0.000115   0.000022         return <SID>JumpOut(a:char, a:pair)
                                endif
                                "echom ' --> '.popped
                                if line[column : column+strlen(popped)-1] != popped
                                    return <SID>JumpOut(a:char, a:pair)
                                endif
                                if column > 0
                                    call setline('.',line[:column-1].line[(column+strlen(popped)):])
                                else
                                    call setline('.','')
                                endif
                                return popped

FUNCTION  neocomplcache#print_debug()
Called 462 times
Total time:   0.002139
 Self time:   0.002139

count  total (s)   self (s)
  462              0.000773   if g:neocomplcache_enable_debug
                                echomsg string(a:expr)
                              endif

FUNCTION  330()
Called 138 times
Total time:   0.010504
 Self time:   0.010504

count  total (s)   self (s)
  138              0.000553     if !exists("self._stl_format")
                                    let self._stl_format = ''
                                endif
  138              0.000412     if !exists("self._stl_flag")
                                    let self._stl_flag = ''
                                endif
                            
  138              0.000418     if g:syntastic_stl_format !=# self._stl_format
                                    let self._stl_format = g:syntastic_stl_format
                            
                                    if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        "sub in the total errors/warnings/both
                                        let output = substitute(output, '\m\C%w', num_warnings, 'g')
                                        let output = substitute(output, '\m\C%e', num_errors, 'g')
                                        let output = substitute(output, '\m\C%t', num_issues, 'g')
                            
                                        "first error/warning line num
                                        let output = substitute(output, '\m\C%F', num_issues ? self._rawLoclist[0]['lnum'] : '', 'g')
                            
                                        "first error line num
                                        let output = substitute(output, '\m\C%fe', num_errors ? errors[0]['lnum'] : '', 'g')
                            
                                        "first warning line num
                                        let output = substitute(output, '\m\C%fw', num_warnings ? warnings[0]['lnum'] : '', 'g')
                            
                                        let self._stl_flag = output
                                    else
                                        let self._stl_flag = ''
                                    endif
                                endif
                            
  138              0.000239     return self._stl_flag

FUNCTION  472()
Called 2 times
Total time:   0.002740
 Self time:   0.001849

count  total (s)   self (s)
    2              0.000005   if g:neocomplcache_max_keyword_width < 0
                                return a:context.candidates
                              endif
                            
                              " Delimiter check.
    2   0.000080   0.000010   let filetype = neocomplcache#get_context_filetype()
                            
    2   0.000836   0.000015   let next_keyword = neocomplcache#filters#converter_remove_next_keyword#get_next_keyword(a:context.source_name)
    8              0.000025   for delimiter in ['/'] + get(g:neocomplcache_delimiter_patterns, filetype, [])
                                " Count match.
    6              0.000010     let delim_cnt = 0
    6              0.000033     let matchend = matchend(a:context.complete_str, delimiter)
    6              0.000010     while matchend >= 0
                                  let matchend = matchend(a:context.complete_str, delimiter, matchend)
                                  let delim_cnt += 1
                                endwhile
                            
   48              0.000055     for candidate in a:context.candidates
   42              0.000255       let split_list = split(candidate.word, delimiter.'\ze.', 1)
   42              0.000081       if len(split_list) > 1
                                    let delimiter_sub = substitute( delimiter, '\\\([.^$]\)', '\1', 'g')
                                    let candidate.word = join(split_list[ : delim_cnt], delimiter_sub)
                                    let candidate.abbr = join( split(get(candidate, 'abbr', candidate.word),             delimiter.'\ze.', 1)[ : delim_cnt], delimiter_sub)
                            
                                    if g:neocomplcache_max_keyword_width >= 0 && len(candidate.abbr) > g:neocomplcache_max_keyword_width
                                      let candidate.abbr = substitute(candidate.abbr, '\(\h\)\w*'.delimiter, '\1'.delimiter_sub, 'g')
                                    endif
                                    if delim_cnt+1 < len(split_list)
                                      let candidate.abbr .= delimiter_sub . '~'
                                      let candidate.dup = 0
                            
                                      if g:neocomplcache_enable_auto_delimiter && next_keyword == ''
                                        let candidate.word .= delimiter_sub
                                      endif
                                    endif
                                  endif
   42              0.000032     endfor
    6              0.000004   endfor
                            
    2              0.000003   return a:context.candidates

FUNCTION  473()
Called 2 times
Total time:   0.002303
 Self time:   0.000027

count  total (s)   self (s)
    2   0.002293   0.000017   if !neocomplcache#is_text_mode() && !neocomplcache#within_comment()
    2              0.000010     return a:context.candidates
                              endif
                            
                              let convert_candidates = filter(copy(a:context.candidates), "get(v:val, 'neocomplcache__convertable', 1)  && v:val.word =~ '^[a-zA-Z0-9_''-]\\+$'")
                            
                              if a:context.complete_str =~ '^\l\+$'
                                for candidate in convert_candidates
                                  let candidate.word = tolower(candidate.word)
                                  if has_key(candidate, 'abbr')
                                    let candidate.abbr = tolower(candidate.abbr)
                                  endif
                                endfor
                              elseif a:context.complete_str =~ '^\u\+$'
                                for candidate in convert_candidates
                                  let candidate.word = toupper(candidate.word)
                                  if has_key(candidate, 'abbr')
                                    let candidate.abbr = toupper(candidate.abbr)
                                  endif
                                endfor
                              elseif a:context.complete_str =~ '^\u\l\+$'
                                for candidate in convert_candidates
                                  let candidate.word = toupper(candidate.word[0]). tolower(candidate.word[1:])
                                  if has_key(candidate, 'abbr')
                                    let candidate.abbr = toupper(candidate.abbr[0]). tolower(candidate.abbr[1:])
                                  endif
                                endfor
                              endif
                            
                              return a:context.candidates

FUNCTION  <SNR>228_debug()
Called 12 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   12              0.000017     if s:debug
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  NumberToggle()
Called 1 time
Total time:   0.000032
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000002   if(&relativenumber == 1)
                                call DisableRelativeNumbers()
                                let g:relativemode = 0
                              else
    1   0.000018   0.000010     call EnableRelativeNumbers()
    1              0.000003     let g:relativemode = 1
    1              0.000001   endif

FUNCTION  neocomplcache#keyword_escape()
Called 330 times
Total time:   0.047186
 Self time:   0.001896

count  total (s)   self (s)
  330   0.047016   0.001726   return neocomplcache#helper#keyword_escape(a:complete_str)

FUNCTION  neocomplcache#init#_filters()
Called 4 times
Total time:   0.000555
 Self time:   0.000526

count  total (s)   self (s)
    4              0.000008   let _ = []
    4   0.000053   0.000024   let filters = neocomplcache#variables#get_filters()
                            
   14              0.000021   for name in a:names
   10              0.000025     if !has_key(filters, name)
                                  " Search autoload.
                                  for filter_name in map(split(globpath(&runtimepath, 'autoload/neocomplcache/filters/'.   substitute(name,'^\%(matcher\|sorter\|converter\)_[^/_-]\+\zs[/_-].*$', '', '')  .'*.vim'), '\n'), "fnamemodify(v:val, ':t:r')")
                                    let filter = neocomplcache#filters#{filter_name}#define()
                                    if empty(filter)
                                      " Ignore.
                                      continue
                                    endif
                            
                                    call neocomplcache#define_filter(filter)
                                  endfor
                            
                                  if !has_key(filters, name)
                                    " Not found.
                                    call neocomplcache#print_error( printf('filter name : %s is not found.', string(name)))
                                    continue
                                  endif
                                endif
                            
   10              0.000025     if has_key(filters, name)
   10              0.000040       call add(_, filters[name])
   10              0.000008     endif
   10              0.000010   endfor
                            
    4              0.000004   return _

FUNCTION  neocomplcache#init#is_enabled()
Called 1543 times
Total time:   0.003399
 Self time:   0.003399

count  total (s)   self (s)
 1543              0.002463   return s:is_enabled

FUNCTION  neocomplcache#sources#buffer_complete#caching_current_line()
Called 4 times
Total time:   0.029308
 Self time:   0.000125

count  total (s)   self (s)
                              " Current line caching.
    4   0.029298   0.000115   return s:caching_current_buffer( max([1, line('.') - 10]), min([line('.') + 10, line('$')]))

FUNCTION  neocomplcache#complete#_get_results()
Called 23 times
Total time:   0.873223
 Self time:   0.001715

count  total (s)   self (s)
   23              0.000040   if g:neocomplcache_enable_debug
                                echomsg 'start get_complete_results'
                              endif
                            
   23   0.000292   0.000104   let neocomplcache = neocomplcache#get_current_neocomplcache()
   23              0.000136   let neocomplcache.start_time = reltime()
                            
   23   0.160962   0.000347   let complete_results = call( 'neocomplcache#complete#_set_results_pos', [a:cur_text] + a:000)
   23   0.711013   0.000308   call neocomplcache#complete#_set_results_words(complete_results)
                            
   23              0.000581   return filter(complete_results, '!empty(v:val.neocomplcache__context.candidates)')

FUNCTION  <SNR>256_getfilename()
Called 24 times
Total time:   0.001953
 Self time:   0.000168

count  total (s)   self (s)
   24   0.001934   0.000149   return s:_encode_name(a:cache_dir, a:filename)

FUNCTION  neocomplcache#helper#get_sources_list()
Called 46 times
Total time:   0.010680
 Self time:   0.006869

count  total (s)   self (s)
   46   0.001909   0.000221   let filetype = neocomplcache#get_context_filetype()
                            
   46              0.000487   let source_names = exists('b:neocomplcache_sources_list') ? b:neocomplcache_sources_list : get(a:000, 0,   get(g:neocomplcache_sources_list, filetype,     get(g:neocomplcache_sources_list, '_', ['_'])))
   46              0.000286   let disabled_sources = get( g:neocomplcache_disabled_sources_list, filetype,   get(g:neocomplcache_disabled_sources_list, '_', []))
   46   0.001282   0.000265   call neocomplcache#init#_sources(source_names)
                            
   46   0.000921   0.000211   let all_sources = neocomplcache#available_sources()
   46              0.000084   let sources = {}
   46              0.000139   for source_name in source_names
   46              0.000081     if source_name ==# '_'
                                  " All sources.
   46              0.000082       let sources = all_sources
   46              0.000046       break
                                endif
                            
                                if !has_key(all_sources, source_name)
                                  call neocomplcache#print_warning(printf( 'Invalid source name "%s" is given.', source_name))
                                  continue
                                endif
                            
                                let sources[source_name] = all_sources[source_name]
                              endfor
                            
   46   0.000652   0.000256   let neocomplcache = neocomplcache#get_current_neocomplcache()
   46              0.003721   let neocomplcache.sources = filter(sources, " index(disabled_sources, v:val.name) < 0 &&   (empty(v:val.filetypes) ||    get(v:val.filetypes, neocomplcache.context_filetype, 0))")
                            
   46              0.000071   return neocomplcache.sources

FUNCTION  neocomplcache#variables#get_sources()
Called 366 times
Total time:   0.002572
 Self time:   0.002572

count  total (s)   self (s)
  366              0.000968   if !exists('s:sources')
                                let s:sources = {}
                              endif
  366              0.000437   return s:sources

FUNCTION  neocomplcache#get_sources_list()
Called 44 times
Total time:   0.006966
 Self time:   0.000297

count  total (s)   self (s)
   44   0.006941   0.000272   return neocomplcache#helper#ftdictionary2list(a:dictionary, a:filetype)

FUNCTION  neocomplcache#handler#_on_insert_enter()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000019   if &l:foldmethod ==# 'expr' && foldlevel('.') != 0
                                foldopen
                              endif

FUNCTION  neocomplcache#get_cur_text()
Called 75 times
Total time:   0.009628
 Self time:   0.001101

count  total (s)   self (s)
                              " Return cached text.
   75   0.001134   0.000416   let neocomplcache = neocomplcache#get_current_neocomplcache()
   75   0.008346   0.000537   return (a:0 == 0 && mode() ==# 'i' &&  neocomplcache.cur_text != '') ? neocomplcache.cur_text : neocomplcache#helper#get_cur_text()

FUNCTION  <SNR>256__create_hash()
Called 24 times
Total time:   0.001035
 Self time:   0.001035

count  total (s)   self (s)
   24              0.000104   if len(a:dir) + len(a:str) < 150
   24              0.000456     let hash = substitute(substitute( a:str, ':', '=-', 'g'), '[/\\]', '=+', 'g')
   24              0.000034   elseif s:exists_md5
                                " Use md5.vim.
                                let hash = md5#md5(a:str)
                              else
                                " Use simple hash.
                                let sum = 0
                                for i in range(len(a:str))
                                  let sum += char2nr(a:str[i]) * (i + 1)
                                endfor
                            
                                let hash = printf('%x', sum)
                              endif
                            
   24              0.000033   return hash

FUNCTION  airline#util#wrap()
Called 1104 times
Total time:   0.008763
 Self time:   0.008763

count  total (s)   self (s)
 1104              0.003342   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1104              0.001692   return a:text

FUNCTION  neocomplcache#util#dup_filter()
Called 44 times
Total time:   0.000670
 Self time:   0.000670

count  total (s)   self (s)
   44              0.000103   let dict = {}
   44              0.000094   for keyword in a:list
                                if !has_key(dict, keyword.word)
                                  let dict[keyword.word] = keyword
                                endif
                              endfor
                            
   44              0.000107   return values(dict)

FUNCTION  neocomplcache#helper#call_filters()
Called 4 times
Total time:   0.007808
 Self time:   0.000431

count  total (s)   self (s)
    4              0.000020   let context = extend(a:source.neocomplcache__context, a:context)
    4              0.000004   let _ = []
   14   0.000627   0.000054   for filter in neocomplcache#init#_filters( neocomplcache#util#convert2list(a:filters))
   10              0.000013     try
   10   0.006934   0.000130       let context.candidates = call(filter.filter, [context], filter)
   10              0.000010     catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error( '[unite.vim] Error occurred in calling filter '   . filter.name . '!')
                                  call neocomplcache#print_error( '[unite.vim] Source name is ' . a:source.name)
                                endtry
   10              0.000016   endfor
                            
    4              0.000004   return context.candidates

FUNCTION  neocomplcache#util#convert2list()
Called 6 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    6              0.000022   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  neocomplcache#handler#_on_complete_done()
Called 2 times
Total time:   0.001184
 Self time:   0.000067

count  total (s)   self (s)
                              " Get cursor word.
    2   0.000900   0.000022   let [_, candidate] = neocomplcache#match_word( neocomplcache#get_cur_text(1))
    2              0.000002   if candidate == ''
                                return
                              endif
                            
    2   0.000251   0.000012   let frequencies = neocomplcache#variables#get_frequencies()
    2              0.000006   if !has_key(frequencies, candidate)
    2              0.000006     let frequencies[candidate] = 20
    2              0.000002   else
                                let frequencies[candidate] += 20
                              endif

FUNCTION  <SNR>64_echo()
Called 4 times
Total time:   0.004778
 Self time:   0.000393

count  total (s)   self (s)
    4   0.004418   0.000033   let line = bufferline#get_echo_string()
                            
                              " 12 is magical and is the threshold for when it doesn't wrap text anymore
    4              0.000011   let width = &columns - 12
    4              0.000007   if g:bufferline_rotate == 2
                                let current_buffer_start = stridx(line, g:bufferline_active_buffer_left)
                                let current_buffer_end = stridx(line, g:bufferline_active_buffer_right)
                                if current_buffer_start < s:window_start
                                  let s:window_start = current_buffer_start
                                endif
                                if current_buffer_end > (s:window_start + width)
                                  let s:window_start = current_buffer_end - width + 1
                                endif
                                let line = strpart(line, s:window_start, width)
                              else
    4              0.000012     let line = strpart(line, 0, width)
    4              0.000003   endif
                            
    4              0.000224   echo line
                            
    4              0.000009   if &updatetime != s:updatetime
    2              0.000009     let &updatetime = s:updatetime
    2              0.000001   endif

FUNCTION  <SNR>94_sub()
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000037   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  neocomplcache#is_text_mode()
Called 158 times
Total time:   0.002985
 Self time:   0.001588

count  total (s)   self (s)
  158   0.002142   0.000745   let neocomplcache = neocomplcache#get_current_neocomplcache()
  158              0.000694   return get(g:neocomplcache_text_mode_filetypes, neocomplcache.context_filetype, 0)

FUNCTION  neocomplcache#check_completion_length_match()
Called 66 times
Total time:   0.009886
 Self time:   0.000982

count  total (s)   self (s)
   66   0.009826   0.000922   return neocomplcache#keyword_escape( a:complete_str[: a:completion_length-1]) =~'[^\\]\*\|\\+\|\\%(\|\\|'

FUNCTION  neosnippet#commands#_make_cache()
Called 136 times
Total time:   0.004946
 Self time:   0.003090

count  total (s)   self (s)
  136   0.001368   0.000525   call neosnippet#init#check()
                            
  136              0.000473   let filetype = a:filetype == '' ? &filetype : a:filetype
  136              0.000211   if filetype ==# ''
                                let filetype = 'nothing'
                              endif
                            
  136   0.001684   0.000671   let snippets = neosnippet#variables#snippets()
  136              0.000370   if has_key(snippets, filetype)
  136              0.000104     return
                              endif
                              let snippets[filetype] = {}
                            
                              let path = join(neosnippet#helpers#get_snippets_directory(), ',')
                              let snippets_files = []
                              for glob in s:get_list().flatten( map(split(get(g:neosnippet#scope_aliases,   filetype, filetype), '\s*,\s*'), "   [v:val . '.snip*', v:val .  '/**/*.snip*'] + (filetype != '_' &&    !has_key(g:neosnippet#scope_aliases, filetype) ?    [v:val . '_*.snip*'] : [])"))
                                let snippets_files += split(globpath(path, glob), '\n')
                              endfor
                            
                              let snippets = neosnippet#variables#snippets()
                              for snippet_file in reverse(s:get_list().uniq(snippets_files))
                                let snippets[filetype] = extend(snippets[filetype], neosnippet#parser#_parse(snippet_file))
                              endfor

FUNCTION  neocomplcache#filters#dictionary_filter()
Called 110 times
Total time:   0.513156
 Self time:   0.005391

count  total (s)   self (s)
  110              0.000315   if empty(a:dictionary)
   44              0.000049     return []
                              endif
                            
   66              0.000141   let completion_length = 2
   66   0.010468   0.000582   if len(a:complete_str) < completion_length || neocomplcache#check_completion_length_match(         a:complete_str, completion_length) || &l:completefunc ==# 'neocomplcache#cunite_complete'
   66   0.501766   0.003887     return neocomplcache#keyword_filter( neocomplcache#unpack_dictionary(a:dictionary), a:complete_str)
                              endif
                            
                              let key = tolower(a:complete_str[: completion_length-1])
                            
                              if !has_key(a:dictionary, key)
                                return []
                              endif
                            
                              let list = a:dictionary[key]
                              if type(list) == type({})
                                " Convert dictionary dictionary.
                                unlet list
                                let list = values(a:dictionary[key])
                              else
                                let list = copy(list)
                              endif
                            
                              return (len(a:complete_str) == completion_length && &ignorecase && !neocomplcache#check_completion_length_match(   a:complete_str, completion_length)) ? list : neocomplcache#keyword_filter(list, a:complete_str)

FUNCTION  425()
Called 25 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
   25              0.000044     if !s:paused || a:forcecurrent
   25              0.000037         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  <SNR>131_sync_active_winnr()
Called 85 times
Total time:   0.001717
 Self time:   0.001717

count  total (s)   self (s)
   85              0.001094   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  neocomplcache#handler#_on_insert_leave()
Called 2 times
Total time:   0.000083
 Self time:   0.000035

count  total (s)   self (s)
    2   0.000033   0.000009   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
    2              0.000005   let neocomplcache.cur_text = ''
    2              0.000006   let neocomplcache.old_cur_text = ''
                            
    2   0.000035   0.000011   call s:close_preview_window()

FUNCTION  neocomplcache#available_sources()
Called 46 times
Total time:   0.000710
 Self time:   0.000407

count  total (s)   self (s)
   46   0.000669   0.000366   return copy(neocomplcache#variables#get_sources())

FUNCTION  neocomplcache#dictionary_filter()
Called 110 times
Total time:   0.514068
 Self time:   0.000912

count  total (s)   self (s)
  110   0.513979   0.000823   return neocomplcache#filters#dictionary_filter(a:dictionary, a:complete_str)

FUNCTION  airline#highlighter#highlight()
Called 5 times
Total time:   0.102056
 Self time:   0.024133

count  total (s)   self (s)
    5              0.000022   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    5              0.000084   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    5              0.000020   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   14              0.000033   for mode in mapped
    9              0.000065     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    9              0.000041       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  169              0.000439       for kvp in items(dict)
  160              0.000406         let mode_colors = kvp[1]
  160   0.009941   0.001465         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
  480              0.000944         for accent in keys(s:accents)
  320              0.000840           if !has_key(p.accents, accent)
                                        continue
                                      endif
  320              0.001131           let colors = copy(mode_colors)
  320              0.000837           if p.accents[accent][0] != ''
  160              0.000483             let colors[0] = p.accents[accent][0]
  160              0.000137           endif
  320              0.000708           if p.accents[accent][2] != ''
  160              0.000469             let colors[2] = p.accents[accent][2]
  160              0.000129           endif
  320              0.000528           if len(colors) >= 5
   86              0.000320             let colors[4] = get(p.accents[accent], 4, '')
   86              0.000072           else
  234              0.001335             call add(colors, get(p.accents[accent], 4, ''))
  234              0.000177           endif
  320   0.018115   0.003312           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
  320              0.000369         endfor
  160              0.000196       endfor
                            
                                  " TODO: optimize this
  126              0.000412       for sep in items(s:separators)
  117   0.056329   0.001685         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  117              0.000139       endfor
    9              0.000009     endif
    9              0.000009   endfor

FUNCTION  <SNR>228_Init()
Called 23 times
Total time:   0.000797
 Self time:   0.000797

count  total (s)   self (s)
   23              0.000056     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
   23              0.000038     if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
   23              0.000032     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
   23              0.000034     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
   23              0.000021     return 1

FUNCTION  neosnippet#variables#snippets()
Called 272 times
Total time:   0.001936
 Self time:   0.001936

count  total (s)   self (s)
  272              0.000678   if !exists('s:snippets')
                                let s:snippets= {}
                              endif
                            
  272              0.000332   return s:snippets

FUNCTION  airline#parts#ffenc()
Called 138 times
Total time:   0.003619
 Self time:   0.003619

count  total (s)   self (s)
  138              0.003481   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  neocomplcache#helper#match_word()
Called 278 times
Total time:   0.053527
 Self time:   0.014727

count  total (s)   self (s)
  278   0.034569   0.001447   let pattern = a:0 >= 1 ? a:1 : neocomplcache#get_keyword_pattern_end()
                            
                              " Check wildcard.
  278   0.016280   0.010602   let complete_pos = s:match_wildcard( a:cur_text, pattern, match(a:cur_text, pattern))
                            
  278              0.001213   let complete_str = (complete_pos >=0) ? a:cur_text[complete_pos :] : ''
                            
  278              0.000622   return [complete_pos, complete_str]

FUNCTION  neocomplcache#get_source_filetypes()
Called 156 times
Total time:   0.018936
 Self time:   0.000988

count  total (s)   self (s)
  156   0.018859   0.000911   return neocomplcache#helper#get_source_filetypes(a:filetype)

FUNCTION  444()
Called 46 times
Total time:   0.005109
 Self time:   0.003250

count  total (s)   self (s)
   46   0.001896   0.000208   let filetype = neocomplcache#get_context_filetype()
                            
                              " Not Filename pattern.
   46              0.000152   if exists('g:neocomplcache_include_patterns')
   46              0.000250     let pattern = get(g:neocomplcache_include_patterns, filetype,      &l:include)
   46              0.000034   else
                                let pattern = ''
                              endif
   46   0.001550   0.001379   if neocomplcache#is_auto_complete() && (pattern == '' || a:cur_text !~ pattern) && a:cur_text =~ '\*$\|\.\.\+$\|/c\%[ygdrive/]$'
                                " Skip filename completion.
                                return -1
                              endif
                            
                              " Check include pattern.
   46              0.000200   let pattern = get(g:neocomplcache_include_patterns, filetype,      &l:include)
   46              0.000518   if pattern == '' || a:cur_text !~ pattern
   46              0.000055     return -1
                              endif
                            
                              let match_end = matchend(a:cur_text, pattern)
                              let complete_str = matchstr(a:cur_text[match_end :], '\f\+')
                            
                              let expr = get(g:neocomplcache_include_exprs, filetype,      &l:includeexpr)
                              if expr != ''
                                let cur_text = substitute(eval(substitute(expr, 'v:fname', string(complete_str), 'g')),  '\.\w*$', '', '')
                              endif
                            
                              let complete_pos = len(a:cur_text) - len(complete_str)
                              if neocomplcache#is_sources_complete() && complete_pos < 0
                                let complete_pos = len(a:cur_text)
                              endif
                            
                              return complete_pos

FUNCTION  tagbar#currenttag()
Called 23 times
Total time:   0.012620
 Self time:   0.001435

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   23              0.000062     let s:statusline_in_use = 1
                            
   23              0.000028     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   23              0.000230         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   23              0.000091         let fullpath  = a:1 =~# 'f'
   23              0.000093         let prototype = a:1 =~# 'p'
   23              0.000023     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   23   0.000916   0.000119     if !s:Init(1)
                                    return a:default
                                endif
                            
   23   0.010602   0.000214     let tag = s:GetNearbyTag(0, 1)
                            
   23              0.000042     if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
   23              0.000038         return a:default
                                endif

FUNCTION  UndotreeUpdate()
Called 87 times
Total time:   0.002200
 Self time:   0.002200

count  total (s)   self (s)
   87              0.001434     if !exists('t:undotree')
   87              0.000310         return
                                endif
                                if !exists('w:undotree_id')
                                    let w:undotree_id = 'id_'.s:getUniqueID()
                                    call s:log("Unique window id assigned: ".w:undotree_id)
                                endif
                                " assume window layout won't change during updating.
                                let thiswinnr = winnr()
                                call t:undotree.Update()
                                " focus moved
                                if winnr() != thiswinnr
                                    call s:exec("norm! ".thiswinnr."\<c-w>\<c-w>")
                                endif

FUNCTION  airline#parts#paste()
Called 138 times
Total time:   0.000746
 Self time:   0.000746

count  total (s)   self (s)
  138              0.000596   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  UpdateMode()
Called 4 times
Total time:   0.000431
 Self time:   0.000379

count  total (s)   self (s)
    4              0.000023   if(&number == 0 && &relativenumber == 0)
                                return
                              end
                            
    4              0.000014   if(g:focus == 0)
                                call DisableRelativeNumbers()
                              elseif(g:insertmode == 0 && g:relativemode == 1)
    1   0.000011   0.000004     call EnableRelativeNumbers()
    1              0.000001   else
    3   0.000094   0.000049     call DisableRelativeNumbers()
    3              0.000005   end
                            
    4              0.000028   if !exists("&numberwidth") || &numberwidth <= 4
                                " Avoid changing actual width of the number column with each jump between
                                " number and relativenumber:
    4              0.000060     let &numberwidth = max([4, 1+len(line('$'))])
    4              0.000006   else
                                " Explanation of the calculation:
                                " - Add 1 to the calculated maximal width to make room for the space
                                " - Assume 4 as the minimum desired width if &numberwidth is not set or is
                                "   smaller than 4
                                let &numberwidth = max([&numberwidth, 1+len(line('$'))])
                              endif

FUNCTION  <SNR>265_is_skip_auto_complete()
Called 23 times
Total time:   0.000951
 Self time:   0.000768

count  total (s)   self (s)
   23   0.000282   0.000099   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
   23              0.000502   if a:cur_text =~ '^\s*$\|\s\+$' || a:cur_text == neocomplcache.old_cur_text || (g:neocomplcache_lock_iminsert && &l:iminsert) || (&l:formatoptions =~# '[tc]' && &l:textwidth > 0     && neocomplcache#util#wcswidth(a:cur_text) >= &l:textwidth)
                                return 1
                              endif
                            
   23              0.000029   if !neocomplcache.skip_next_complete
   23              0.000021     return 0
                              endif
                            
                              " Check delimiter pattern.
                              let is_delimiter = 0
                              let filetype = neocomplcache#get_context_filetype()
                            
                              for delimiter in ['/', '\.'] + get(g:neocomplcache_delimiter_patterns, filetype, [])
                                if a:cur_text =~ delimiter . '$'
                                  let is_delimiter = 1
                                  break
                                endif
                              endfor
                            
                              if is_delimiter && neocomplcache.skip_next_complete == 2
                                let neocomplcache.skip_next_complete = 0
                                return 0
                              endif
                            
                              let neocomplcache.skip_next_complete = 0
                              let neocomplcache.cur_text = ''
                              let neocomplcache.old_cur_text = ''
                            
                              return 1

FUNCTION  neocomplcache#helper#ftdictionary2list()
Called 44 times
Total time:   0.006669
 Self time:   0.001313

count  total (s)   self (s)
   44              0.000072   let list = []
   88   0.005660   0.000304   for filetype in neocomplcache#get_source_filetypes(a:filetype)
   44              0.000119     if has_key(a:dictionary, filetype)
   44              0.000353       call add(list, a:dictionary[filetype])
   44              0.000037     endif
   44              0.000036   endfor
                            
   44              0.000050   return list

FUNCTION  neocomplcache#helper#call_hook()
Called 2 times
Total time:   0.000151
 Self time:   0.000141

count  total (s)   self (s)
    4   0.000026   0.000016   for source in neocomplcache#util#convert2list(a:sources)
    2              0.000006     try
    2              0.000006       if !has_key(source.hooks, a:hook_name)
    2              0.000006         if a:hook_name ==# 'on_init' && has_key(source, 'initialize')
                                      call source.initialize()
                                    elseif a:hook_name ==# 'on_final' && has_key(source, 'finalize')
                                      call source.finalize()
                                    endif
    2              0.000002       else
                                    call call(source.hooks[a:hook_name], [extend(source.neocomplcache__context, a:context)], source.hooks)
                                  endif
    2              0.000002     catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error( '[unite.vim] Error occurred in calling hook "' . a:hook_name . '"!')
                                  call neocomplcache#print_error( '[unite.vim] Source name is ' . source.name)
                                endtry
    2              0.000002   endfor

FUNCTION  airline#parts#readonly()
Called 138 times
Total time:   0.000892
 Self time:   0.000892

count  total (s)   self (s)
  138              0.000669   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  <SNR>246_check_source()
Called 22 times
Total time:   0.038619
 Self time:   0.017715

count  total (s)   self (s)
   22   0.000215   0.000090   if !s:exists_current_source()
                                call neocomplcache#sources#buffer_complete#caching_current_block()
                                return
                              endif
                            
  352              0.000589   for bufnumber in range(1, bufnr('$'))
                                " Check new buffer.
  330              0.004405     let bufname = fnamemodify(bufname(bufnumber), ':p')
  330   0.015173   0.004700     if (!has_key(s:buffer_sources, bufnumber) || s:check_changed_buffer(bufnumber)) && !has_key(s:disable_caching_list, bufnumber) && (!neocomplcache#is_locked(bufnumber) ||    g:neocomplcache_disable_auto_complete) && !getwinvar(bufwinnr(bufnumber), '&previewwindow') && getfsize(bufname) <      g:neocomplcache_caching_limit_file_size
                                  " Caching.
   24   0.008573   0.000154       call s:word_caching(bufnumber)
   24              0.000019     endif
                            
  330              0.000876     if has_key(s:buffer_sources, bufnumber)
  330              0.000932       let source = s:buffer_sources[bufnumber]
  330   0.005160   0.003273       call neocomplcache#cache#check_cache_list('buffer_cache', source.path, s:async_dictionary_list, source.keyword_cache, 1)
  330              0.000237     endif
  330              0.000233   endfor

FUNCTION  neocomplcache#variables#get_frequencies()
Called 4 times
Total time:   0.000495
 Self time:   0.000106

count  total (s)   self (s)
    4              0.000016   if !exists('s:filetype_frequencies')
                                let s:filetype_frequencies = {}
                              endif
    4   0.000416   0.000027   let filetype = neocomplcache#context_filetype#get(&filetype)
    4              0.000013   if !has_key(s:filetype_frequencies, filetype)
                                let s:filetype_frequencies[filetype] = {}
                              endif
                            
    4              0.000012   let frequencies = s:filetype_frequencies[filetype]
                            
    4              0.000004   return frequencies

FUNCTION  <SNR>265_save_foldinfo()
Called 23 times
Total time:   0.000993
 Self time:   0.000993

count  total (s)   self (s)
                              " Save foldinfo.
   23              0.000291   let winnrs = filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')")
                            
                              " Note: for foldmethod=expr or syntax.
   23              0.000350   call filter(winnrs, "  (getwinvar(v:val, '&foldmethod') ==# 'expr' ||   getwinvar(v:val, '&foldmethod') ==# 'syntax') &&  getwinvar(v:val, '&modifiable')")
   23              0.000051   for winnr in winnrs
                                call setwinvar(winnr, 'neocomplcache_foldinfo', { 'foldmethod' : getwinvar(winnr, '&foldmethod'), 'foldexpr'   : getwinvar(winnr, '&foldexpr') })
                                call setwinvar(winnr, '&foldmethod', 'manual')
                                call setwinvar(winnr, '&foldexpr', 0)
                              endfor

FUNCTION  <SNR>248_keyword_escape()
Called 330 times
Total time:   0.011758
 Self time:   0.011758

count  total (s)   self (s)
  330              0.002136   let keyword_escape = escape(a:complete_str, '~" \.^$[]')
  330              0.000572   if g:neocomplcache_enable_wildcard
  330              0.006490     let keyword_escape = substitute( substitute(keyword_escape, '.\zs\*', '.*', 'g'), '\%(^\|\*\)\zs\*', '\\*', 'g')
  330              0.000333   else
                                let keyword_escape = escape(keyword_escape, '*')
                              endif
                            
  330              0.000478   return keyword_escape

FUNCTION  <SNR>143_exec_separator()
Called 117 times
Total time:   0.054644
 Self time:   0.004657

count  total (s)   self (s)
  117   0.025168   0.000718   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  117   0.020759   0.000775   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  117              0.000465   let group = a:from.'_to_'.a:to.a:suffix
  117              0.000129   if a:inverse
   18              0.000094     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   18              0.000014   else
   99              0.000534     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   99              0.000074   endif
  117              0.000470   let a:dict[group] = colors
  117   0.006304   0.000751   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>228_AutoUpdate()
Called 2 times
Total time:   0.001496
 Self time:   0.000778

count  total (s)   self (s)
    2   0.000040   0.000019     call s:debug('AutoUpdate called [' . a:fname . ']')
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    2              0.000006     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call s:debug('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    2              0.000079     let bufnr = bufnr(a:fname)
    2              0.000010     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    2              0.000004     if ftype == 'tagbar'
                                    call s:debug('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    2              0.000015     let sftype = get(split(ftype, '\.'), 0, '')
    2   0.000033   0.000017     call s:debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    2   0.000289   0.000014     if !s:IsValidFile(a:fname, sftype)
                                    call s:debug('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
                                endif
                            
    2              0.000004     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    2   0.000023   0.000015     if s:known_files.has(a:fname)
    2   0.000020   0.000010         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    2              0.000028         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call s:debug('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
    2   0.000027   0.000012             call s:debug('File data seems up to date [' . a:fname . ']')
    2              0.000001         endif
    2              0.000003     elseif !s:known_files.has(a:fname)
                                    call s:debug('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
    2   0.000017   0.000009     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    2              0.000003     if empty(fileinfo)
                                    call s:debug('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    2              0.000341     if bufwinnr('__Tagbar__') != -1 && !s:paused && (s:new_window || updated || (!empty(s:known_files.getCurrent(0)) && a:fname != s:known_files.getCurrent(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    2              0.000004     if !empty(fileinfo)
    2   0.000033   0.000018         call s:debug('Setting current file [' . a:fname . ']')
    2   0.000017   0.000011         call s:known_files.setCurrent(fileinfo)
    2              0.000004         let s:nearby_disabled = 0
    2              0.000002     endif
                            
    2   0.000345   0.000014     call s:HighlightTag(0)
    2   0.000031   0.000018     call s:debug('AutoUpdate finished successfully')

FUNCTION  neocomplcache#sources#buffer_complete#get_frequencies()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                              " Current line caching.
    2              0.000015   return get(get(s:buffer_sources, bufnr('%'), {}), 'frequencies', {})

FUNCTION  airline#highlighter#exec()
Called 602 times
Total time:   0.029099
 Self time:   0.029099

count  total (s)   self (s)
  602              0.001265   let colors = a:colors
  602              0.000820   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  602              0.021550   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  neocomplcache#cache#check_cache_list()
Called 418 times
Total time:   0.002411
 Self time:   0.002411

count  total (s)   self (s)
  418              0.001672   if !has_key(a:async_cache_dictionary, a:key)
  418              0.000353     return
                              endif
                            
                              let is_string = get(a:000, 0, 0)
                            
                              let keyword_list = []
                              let cache_list = a:async_cache_dictionary[a:key]
                              for cache in cache_list
                                if filereadable(cache.cachename)
                                  let keyword_list += neocomplcache#cache#load_from_cache( a:cache_dir, cache.filename, is_string)
                                endif
                              endfor
                            
                              call neocomplcache#cache#list2index(keyword_list, a:index_keyword_list, is_string)
                              call filter(cache_list, '!filereadable(v:val.cachename)')
                            
                              if empty(cache_list)
                                " Delete from dictionary.
                                call remove(a:async_cache_dictionary, a:key)
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 138 times
Total time:   0.007946
 Self time:   0.007488

count  total (s)   self (s)
  138              0.000795   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
  138              0.000639   if !exists('b:airline_whitespace_check')
    2              0.000006     let b:airline_whitespace_check = ''
    2              0.000009     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    2              0.000004     let trailing = 0
    2              0.000006     if index(checks, 'trailing') > -1
    2              0.000211       let trailing = search('\s$', 'nw')
    2              0.000001     endif
                            
    2              0.000003     let mixed = 0
    2              0.000004     if index(checks, 'indent') > -1
    2   0.000475   0.000017       let mixed = s:check_mixed_indent()
    2              0.000002     endif
                            
    2              0.000004     if trailing != 0 || mixed != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                  endif
                                endif
    2              0.000002   endif
  138              0.000297   return b:airline_whitespace_check

FUNCTION  <SNR>246_check_changed_buffer()
Called 326 times
Total time:   0.009675
 Self time:   0.009675

count  total (s)   self (s)
  326              0.001143   let source = s:buffer_sources[a:bufnumber]
                            
  326              0.001298   let ft = getbufvar(a:bufnumber, '&filetype')
  326              0.000543   if ft == ''
   40              0.000067     let ft = 'nothing'
   40              0.000032   endif
                            
  326              0.001441   let filename = fnamemodify(bufname(a:bufnumber), ':t')
  326              0.000553   if filename == ''
   20              0.000038     let filename = '[No Name]'
   20              0.000017   endif
                            
  326              0.002249   return s:buffer_sources[a:bufnumber].name != filename || s:buffer_sources[a:bufnumber].filetype != ft

FUNCTION  EnableRelativeNumbers()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000009   set number
    2              0.000003   set relativenumber

FUNCTION  <SNR>256__encode_name()
Called 24 times
Total time:   0.001785
 Self time:   0.000750

count  total (s)   self (s)
                              " Check cache directory.
   24              0.000106   if !isdirectory(a:cache_dir)
                                call mkdir(a:cache_dir, 'p')
                              endif
   24              0.000055   let cache_dir = a:cache_dir
   24              0.000192   if cache_dir !~ '/$'
   24              0.000061     let cache_dir .= '/'
   24              0.000018   endif
                            
   24   0.001199   0.000164   return cache_dir . s:_create_hash(cache_dir, a:filename)

FUNCTION  <SNR>246_get_sources_list()
Called 22 times
Total time:   0.009582
 Self time:   0.005939

count  total (s)   self (s)
   22              0.000049   let sources_list = []
                            
   22              0.000042   let filetypes_dict = {}
   44   0.003869   0.000226   for filetype in neocomplcache#get_source_filetypes( neocomplcache#get_context_filetype())
   22              0.000062     let filetypes_dict[filetype] = 1
   22              0.000019   endfor
                            
  352              0.000952   for [key, source] in items(s:buffer_sources)
  330              0.002572     if has_key(filetypes_dict, source.filetype) || has_key(filetypes_dict, '_') || bufnr('%') == key || (source.name ==# '[Command Line]' && bufnr('#') == key)
   44              0.000310       call add(sources_list, [key, source])
   44              0.000039     endif
  330              0.000409   endfor
                            
   22              0.000032   return sources_list

FUNCTION  437()
Called 22 times
Total time:   0.009815
 Self time:   0.001681

count  total (s)   self (s)
   22              0.000043   let list = []
                            
   22   0.001332   0.000190   let filetype = neocomplcache#is_text_mode() ? 'text' : neocomplcache#get_context_filetype()
   22              0.000075   if !has_key(s:dictionary_list, filetype)
                                " Caching.
                                call s:caching()
                              endif
                            
   44   0.002844   0.000195   for ft in neocomplcache#get_source_filetypes(filetype)
   22   0.000906   0.000288     call neocomplcache#cache#check_cache('dictionary_cache', ft, s:async_dictionary_list, s:dictionary_list, 1)
                            
   44   0.003630   0.000156     for dict in neocomplcache#get_sources_list(s:dictionary_list, ft)
   22   0.000435   0.000184       let list += neocomplcache#dictionary_filter(dict, a:complete_str)
   22              0.000023     endfor
   22              0.000021   endfor
                            
   22              0.000022   return list

FUNCTION  <SNR>94_repo()
Called 4 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    4              0.000031   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
    4              0.000005   if dir !=# ''
    4              0.000009     if has_key(s:repos, dir)
    4              0.000012       let repo = get(s:repos, dir)
    4              0.000004     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
    4              0.000042     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>94_repo_head()
Called 2 times
Total time:   0.000407
 Self time:   0.000092

count  total (s)   self (s)
    2   0.000297   0.000021     let head = s:repo().head_ref()
                            
    2              0.000027     if head =~# '^ref: '
    2   0.000057   0.000018       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
    2              0.000002     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
    2              0.000003     return branch

FUNCTION  neocomplcache#util#substitute_path_separator()
Called 24 times
Total time:   0.000359
 Self time:   0.000242

count  total (s)   self (s)
   24   0.000342   0.000225   return call(s:V.substitute_path_separator, a:000)

FUNCTION  neocomplcache#dup_filter()
Called 44 times
Total time:   0.000953
 Self time:   0.000283

count  total (s)   self (s)
   44   0.000905   0.000235   return neocomplcache#util#dup_filter(a:list)

FUNCTION  neocomplcache#get_next_keyword_pattern()
Called 4 times
Total time:   0.000948
 Self time:   0.000096

count  total (s)   self (s)
    4   0.000169   0.000024   let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
    4   0.000383   0.000031   let next_pattern = neocomplcache#helper#unite_patterns( g:neocomplcache_next_keyword_patterns, filetype)
                            
    4   0.000389   0.000034   return (next_pattern == '' ? '' : next_pattern.'\m\|') . neocomplcache#get_keyword_pattern(filetype)

FUNCTION  <SNR>272_is_beginning_of_line()
Called 68 times
Total time:   0.002268
 Self time:   0.002268

count  total (s)   self (s)
   68              0.000165   let keyword_pattern = '\S\+'
   68              0.000981   let cur_keyword_str = matchstr(a:cur_text, keyword_pattern.'$')
   68              0.000366   let line_part = a:cur_text[: -1-len(cur_keyword_str)]
   68              0.000464   let prev_word_end = matchend(line_part, keyword_pattern)
                            
   68              0.000116   return prev_word_end <= 0

FUNCTION  <SNR>248_match_wildcard()
Called 278 times
Total time:   0.005678
 Self time:   0.005678

count  total (s)   self (s)
  278              0.000798   let complete_pos = a:complete_pos
  278              0.001330   while complete_pos > 1 && a:cur_text[complete_pos - 1] == '*'
                                let left_text = a:cur_text[: complete_pos - 2]
                                if left_text == '' || left_text !~ a:pattern
                                  break
                                endif
                            
                                let complete_pos = match(left_text, a:pattern)
                              endwhile
                            
  278              0.000353   return complete_pos

FUNCTION  neocomplcache#match_word()
Called 278 times
Total time:   0.055300
 Self time:   0.001773

count  total (s)   self (s)
  278   0.055129   0.001602   return call('neocomplcache#helper#match_word', a:000)

FUNCTION  neocomplcache#filters#keyword_filter()
Called 178 times
Total time:   0.450993
 Self time:   0.402037

count  total (s)   self (s)
  178              0.000541   let complete_str = a:complete_str
                            
  178              0.000339   if g:neocomplcache_enable_debug
                                echomsg len(a:list)
                              endif
                            
                              " Delimiter check.
  178   0.008710   0.001066   let filetype = neocomplcache#get_context_filetype()
  534              0.001554   for delimiter in get(g:neocomplcache_delimiter_patterns, filetype, [])
  356              0.003079     let complete_str = substitute(complete_str, delimiter, '*' . delimiter, 'g')
  356              0.000361   endfor
                            
  178              0.001044   if complete_str == '' || &l:completefunc ==# 'neocomplcache#complete#unite_complete' || empty(a:list)
   46              0.000061     return a:list
                              elseif neocomplcache#check_match_filter(complete_str)
                                " Match filter.
  132              0.000780     let word = type(a:list[0]) == type('') ? 'v:val' : 'v:val.word'
                            
  132   0.019240   0.001581     let expr = printf('%s =~ %s', word, string('^' . neocomplcache#keyword_escape(complete_str)))
  132   0.001247   0.000693     if neocomplcache#is_auto_complete()
                                  " Don't complete cursor word.
  132              0.000663       let expr .= printf(' && %s !=? a:complete_str', word)
  132              0.000103     endif
                            
                                " Check head character.
  132              0.000617     if complete_str[0] != '\' && complete_str[0] != '.'
  132              0.000826       let expr = word.'[0] == ' . string(complete_str[0]) .' && ' . expr
  132              0.000113     endif
                            
  132   0.001349   0.000751     call neocomplcache#print_debug(expr)
                            
  132              0.383473     return filter(a:list, expr)
                              else
                                " Use fast filter.
                                return s:head_filter(a:list, complete_str)
                              endif

FUNCTION  <SNR>265_close_preview_window()
Called 25 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
   25              0.000218   if g:neocomplcache_enable_auto_close_preview && bufname('%') !=# '[Command Line]' && winnr('$') != 1 && !&l:previewwindow
                                " Close preview window.
                                pclose!
                              endif

FUNCTION  417()
Called 40 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
   40              0.000126     let idx = self.kinddict[a:kind]
   40              0.000095     return self.kinds[idx]

FUNCTION  <SNR>64_cursorhold_callback()
Called 2 times
Total time:   0.002281
 Self time:   0.000026

count  total (s)   self (s)
    2   0.002266   0.000011   call s:echo()
    2              0.000015   autocmd! bufferline CursorHold

FUNCTION  neocomplcache#keyword_filter()
Called 178 times
Total time:   0.452676
 Self time:   0.001683

count  total (s)   self (s)
  178   0.452412   0.001419   return neocomplcache#filters#keyword_filter(a:list, a:complete_str)

FUNCTION  <SNR>239_uniq()
Called 202 times
Total time:   0.009420
 Self time:   0.009420

count  total (s)   self (s)
  202              0.001176   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
  202              0.000313   let i = 0
  202              0.000348   let seen = {}
  404              0.000930   while i < len(list)
  202              0.001166     let key = string(a:0 ? list[i][1] : list[i])
  202              0.000465     if has_key(seen, key)
                                  call remove(list, i)
                                else
  202              0.000575       let seen[key] = 1
  202              0.000344       let i += 1
  202              0.000155     endif
  202              0.000162   endwhile
  202              0.000463   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  426()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000006     let self._current = a:fileinfo

FUNCTION  428()
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000017     return get(self._files, a:fname, {})

FUNCTION  InsertLeave()
Called 2 times
Total time:   0.000109
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000005   let g:insertmode = 0
    2   0.000103   0.000007   call UpdateMode()

FUNCTION  neocomplcache#is_auto_complete()
Called 954 times
Total time:   0.003768
 Self time:   0.003768

count  total (s)   self (s)
  954              0.003286   return &l:completefunc == 'neocomplcache#complete#auto_complete'

FUNCTION  <SNR>136_get_hunks_signify()
Called 138 times
Total time:   0.003734
 Self time:   0.001876

count  total (s)   self (s)
  138   0.002797   0.000939   let hunks = sy#repo#get_stats()
  138              0.000425   if hunks[0] >= 0
  138              0.000201     return hunks
                              endif
                              return []

FUNCTION  airline#extensions#branch#head()
Called 138 times
Total time:   0.001954
 Self time:   0.001437

count  total (s)   self (s)
  138              0.000839   if exists('b:airline_head') && !empty(b:airline_head)
  136              0.000272     return b:airline_head
                              endif
                            
    2              0.000004   let b:airline_head = ''
    2              0.000004   let found_fugitive_head = 0
                            
    2              0.000007   if s:has_fugitive && !exists('b:mercurial_dir')
    2   0.000534   0.000017     let b:airline_head = fugitive#head(7)
    2              0.000003     let found_fugitive_head = 1
                            
    2              0.000006     if empty(b:airline_head) && !exists('b:git_dir')
                                  let b:airline_head = s:get_git_branch(expand("%:p:h"))
                                endif
    2              0.000001   endif
                            
    2              0.000004   if empty(b:airline_head)
                                if s:has_lawrencium
                                  let b:airline_head = lawrencium#statusline()
                                endif
                              endif
                            
    2              0.000004   if empty(b:airline_head)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = get(b:VCSCommandBufferInfo, 0, '')
                                  endif
                                endif
                              endif
                            
    2              0.000008   if empty(b:airline_head) || !found_fugitive_head && !s:check_in_path()
                                let b:airline_head = ''
                              endif
                            
    2              0.000008   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:w:displayed_head_limit - 1].''
                                endif
                              endif
                            
    2              0.000002   return b:airline_head

FUNCTION  neosnippet#init#check()
Called 204 times
Total time:   0.001364
 Self time:   0.001364

count  total (s)   self (s)
  204              0.000605   if !exists('s:is_initialized')
                                call neosnippet#init#_initialize()
                              endif

FUNCTION  <SNR>94_repo_head_ref()
Called 2 times
Total time:   0.000220
 Self time:   0.000183

count  total (s)   self (s)
    2   0.000090   0.000069   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
    2   0.000121   0.000105   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>246_exists_current_source()
Called 26 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
   26              0.000156   return has_key(s:buffer_sources, bufnr('%'))

FUNCTION  neocomplcache#complete#_set_results_pos()
Called 46 times
Total time:   0.321242
 Self time:   0.045087

count  total (s)   self (s)
                              " Set context filetype.
   46   0.013529   0.000279   call neocomplcache#context_filetype#set()
                            
                              " Initialize sources.
   46   0.000768   0.000383   let neocomplcache = neocomplcache#get_current_neocomplcache()
   46   0.003374   0.003051   for source in filter(values(neocomplcache#variables#get_sources()), '!v:val.loaded && (empty(v:val.filetypes) ||       get(v:val.filetypes,             neocomplcache.context_filetype, 0))')
                                call neocomplcache#helper#call_hook(source, 'on_init', {})
                                let source.loaded = 1
                              endfor
                            
   46   0.011862   0.001182   let sources = filter(copy(get(a:000, 0, neocomplcache#helper#get_sources_list())), 'v:val.loaded')
   46              0.000061   if a:0 < 1
   46   0.015974   0.002660     call filter(sources, '!neocomplcache#is_plugin_locked(v:key)')
   46              0.000033   endif
                            
                              " Try source completion. "{{{
   46              0.000097   let complete_sources = []
  506              0.000898   for source in values(sources)
  460              0.001061     let context = source.neocomplcache__context
  460              0.001163     let context.input = a:cur_text
  460              0.000823     let context.complete_pos = -1
  460              0.000806     let context.complete_str = ''
  460              0.000926     let context.candidates = []
                            
  460              0.001586     let pos = winsaveview()
                            
  460              0.000647     try
  460   0.228713   0.006312       let complete_pos = has_key(source, 'get_keyword_pos') ? source.get_keyword_pos(context.input) : has_key(source, 'get_complete_position') ? source.get_complete_position(context) : neocomplcache#match_word(context.input)[0]
  460              0.000501     catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error( 'Error occurred in source''s get_complete_position()!')
                                  call neocomplcache#print_error( 'Source name is ' . source.name)
                                  return complete_sources
                                finally
  460              0.001926       if winsaveview() != pos
                                    call winrestview(pos)
                                  endif
  460              0.000436     endtry
                            
  460              0.000668     if complete_pos < 0
  186              0.000371       continue
                                endif
                            
  274              0.000956     let complete_str = context.input[complete_pos :]
  274   0.019543   0.003741     if neocomplcache#is_auto_complete() && neocomplcache#util#mb_strlen(complete_str)     < neocomplcache#get_completion_length(source.name)
                                  " Skip.
   10              0.000015       continue
                                endif
                            
  264              0.000652     let context.complete_pos = complete_pos
  264              0.000585     let context.complete_str = complete_str
  264              0.001143     call add(complete_sources, source)
  264              0.000316   endfor
                              "}}}
                            
   46              0.000065   return complete_sources

FUNCTION  430()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007     return has_key(self._files, a:fname)

FUNCTION  airline#parts#mode()
Called 138 times
Total time:   0.000911
 Self time:   0.000911

count  total (s)   self (s)
  138              0.000757   return get(w:, 'airline_current_mode', '')

FUNCTION  DisableRelativeNumbers()
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000025   set number
    3              0.000010   set norelativenumber

FUNCTION  <SNR>143_get_array()
Called 234 times
Total time:   0.003194
 Self time:   0.003194

count  total (s)   self (s)
  234              0.000467   let fg = a:fg
  234              0.000393   let bg = a:bg
  234              0.002070   return has('gui_running') ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  sy#repo#get_stats()
Called 138 times
Total time:   0.001858
 Self time:   0.001858

count  total (s)   self (s)
  138              0.000894   if !exists('b:sy') || !has_key(b:sy, 'stats')
                                return [-1, -1, -1]
                              endif
                            
  138              0.000258   return b:sy.stats

FUNCTION  <SNR>141_check_mixed_indent()
Called 2 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
    2              0.000003   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less then tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              else
    2              0.000437     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  440()
Called 46 times
Total time:   0.012526
 Self time:   0.002008

count  total (s)   self (s)
   46   0.001917   0.000201   let filetype = neocomplcache#get_context_filetype()
   46              0.000166   if filetype ==# 'vimshell' || filetype ==# 'unite' || filetype ==# 'int-ssh'
                                return -1
                              endif
                            
                              " Filename pattern.
   46   0.005132   0.000274   let pattern = neocomplcache#get_keyword_pattern_end('filename')
   46   0.004239   0.000468   let [complete_pos, complete_str] = neocomplcache#match_word(a:cur_text, pattern)
   46   0.000713   0.000540   if complete_str =~ '//' || (neocomplcache#is_auto_complete() &&    (complete_str !~ '/' ||     complete_str =~#          '\\[^ ;*?[]"={}'']\|\.\.\+$\|/c\%[ygdrive/]$'))
                                " Not filename pattern.
   46              0.000050     return -1
                              endif
                            
                              if neocomplcache#is_sources_complete() && complete_pos < 0
                                let complete_pos = len(a:cur_text)
                              endif
                            
                              return complete_pos

FUNCTION  448()
Called 22 times
Total time:   0.017357
 Self time:   0.001476

count  total (s)   self (s)
   22   0.013156   0.000113   if neocomplcache#within_comment()
                                return []
                              endif
                            
   22              0.000161   if !has_key(s:include_info, bufnr('%'))
                                " Auto caching.
                                call s:check_buffer('', 0)
                              endif
                            
   22              0.000069   let keyword_list = []
                            
                              " Check caching.
   22              0.000132   for include in s:include_info[bufnr('%')].include_files
                                call neocomplcache#cache#check_cache( 'include_cache', include, s:async_include_cache, s:include_cache)
                                if has_key(s:include_cache, include)
                                  let s:cache_accessed_time[include] = localtime()
                                  let keyword_list += neocomplcache#dictionary_filter( s:include_cache[include], a:complete_str)
                                endif
                              endfor
                            
   22   0.003207   0.000369   return neocomplcache#keyword_filter( neocomplcache#dup_filter(keyword_list), a:complete_str)

FUNCTION  451()
Called 46 times
Total time:   0.004315
 Self time:   0.002412

count  total (s)   self (s)
                              " Check member prefix pattern.
   46   0.001777   0.000203   let filetype = neocomplcache#get_context_filetype()
   46              0.000273   if !has_key(g:neocomplcache_member_prefix_patterns, filetype) || g:neocomplcache_member_prefix_patterns[filetype] == ''
                                return -1
                              endif
                            
   46   0.000632   0.000303   let member = s:get_member_pattern(filetype)
   46              0.000146   let prefix = g:neocomplcache_member_prefix_patterns[filetype]
   46              0.001153   let complete_pos = matchend(a:cur_text, '\%(' . member . '\%(' . prefix . '\m\)\)\+\ze\w*$')
   46              0.000066   return complete_pos

FUNCTION  <SNR>253_get_complete_pos()
Called 46 times
Total time:   0.000239
 Self time:   0.000239

count  total (s)   self (s)
   46              0.000120   if empty(a:complete_results)
   46              0.000051     return -1
                              endif
                            
                              let complete_pos = col('.')
                              for result in values(a:complete_results)
                                if complete_pos > result.complete_pos
                                  let complete_pos = result.complete_pos
                                endif
                              endfor
                            
                              return complete_pos

FUNCTION  neocomplcache#is_enabled()
Called 1543 times
Total time:   0.010060
 Self time:   0.006661

count  total (s)   self (s)
 1543   0.009302   0.005903   return neocomplcache#init#is_enabled()

FUNCTION  459()
Called 22 times
Total time:   0.453971
 Self time:   0.001483

count  total (s)   self (s)
   22              0.000044   let list = []
                            
   22   0.000862   0.000092   let filetype = neocomplcache#get_context_filetype()
   22              0.000077   if !has_key(s:syntax_list, filetype)
                                call s:caching()
                              endif
                            
   44   0.003722   0.000230   for syntax in neocomplcache#get_sources_list( s:syntax_list, filetype)
   22   0.448535   0.000309     let list += neocomplcache#dictionary_filter(syntax, a:complete_str)
   22              0.000311   endfor
                            
   22              0.000070   return list

FUNCTION  neocomplcache#util#mb_strlen()
Called 274 times
Total time:   0.002682
 Self time:   0.001826

count  total (s)   self (s)
  274   0.002531   0.001675   return call(s:String.strchars, a:000)

FUNCTION  434()
Called 22 times
Total time:   0.117098
 Self time:   0.003276

count  total (s)   self (s)
   22   0.038784   0.000165   call s:check_source()
                            
   22              0.000047   let keyword_list = []
   66   0.009923   0.000341   for [key, source] in s:get_sources_list()
   44   0.001635   0.001355     call neocomplcache#cache#check_cache_list('buffer_cache', source.path, s:async_dictionary_list, source.keyword_cache, 1)
                            
   44   0.065810   0.000469     let keyword_list += neocomplcache#dictionary_filter( source.keyword_cache, a:context.complete_str)
   44              0.000242     if key == bufnr('%')
   22              0.000079       let source.accessed_time = localtime()
   22              0.000015     endif
   44              0.000037   endfor
                            
   22              0.000032   return keyword_list

FUNCTION  neocomplcache#filters#converter_remove_next_keyword#get_next_keyword()
Called 4 times
Total time:   0.001780
 Self time:   0.000173

count  total (s)   self (s)
    4   0.000997   0.000049   let pattern = '^\%(' . ((a:source_name ==# 'filename_complete' ||  a:source_name ==# 'filename_complete') ?   neocomplcache#get_next_keyword_pattern('filename') :   neocomplcache#get_next_keyword_pattern()) . '\m\)'
                            
    4   0.000767   0.000108   let next_keyword = matchstr('a'. getline('.')[len(neocomplcache#get_cur_text(1)) :], pattern)[1:]
    4              0.000006   return next_keyword

FUNCTION  468()
Called 46 times
Total time:   0.102674
 Self time:   0.015775

count  total (s)   self (s)
   46              0.000585   let cur_word = matchstr(a:cur_text, '\w\+$')
   46   0.101092   0.014193   let word_candidates = neocomplcache#keyword_filter( filter(values(neosnippet#helpers#get_snippets()), 'v:val.options.word'), cur_word)
   46              0.000104   if !empty(word_candidates)
    2              0.000030     return match(a:cur_text, '\w\+$')
                              endif
                            
   44              0.000631   return match(a:cur_text, '\S\+$')

FUNCTION  neocomplcache#util#expand()
Called 24 times
Total time:   0.000459
 Self time:   0.000459

count  total (s)   self (s)
   24              0.000443   return expand(escape(a:path, '*?[]"={}'), 1)

FUNCTION  neocomplcache#get_keyword_pattern_end()
Called 278 times
Total time:   0.037980
 Self time:   0.003571

count  total (s)   self (s)
  278   0.009665   0.001452   let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                            
  278   0.028038   0.001842   return '\%('.neocomplcache#get_keyword_pattern(filetype).'\m\)$'

FUNCTION  <SNR>272_get_sources_filetypes()
Called 68 times
Total time:   0.009512
 Self time:   0.001277

count  total (s)   self (s)
   68   0.009241   0.001006   let filetypes = exists('*neocomplete#get_source_filetypes') ?   neocomplete#get_source_filetypes(a:filetype) : exists('*neocomplcache#get_source_filetypes') ?   neocomplcache#get_source_filetypes(a:filetype) : split(((a:filetype == '') ? 'nothing' : a:filetype), '\.')
   68              0.000173   return filetypes + ['_']

FUNCTION  airline#statusline()
Called 138 times
Total time:   0.004356
 Self time:   0.004356

count  total (s)   self (s)
  138              0.002039   if has_key(s:contexts, a:winnr)
  138              0.001718     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  471()
Called 2 times
Total time:   0.001064
 Self time:   0.000105

count  total (s)   self (s)
                              " Remove next keyword.
    2   0.000983   0.000024   let next_keyword = neocomplcache#filters#converter_remove_next_keyword#get_next_keyword(a:context.source_name)
    2              0.000003   if next_keyword == ''
    1              0.000002     return a:context.candidates
                              endif
                            
    1              0.000013   let next_keyword = substitute( substitute(escape(next_keyword, '~" \.^$*[]'), "'", "''", 'g'), ')$', '', '').'$'
                            
                              " No ignorecase.
    1              0.000003   let ignorecase_save = &ignorecase
    1              0.000003   let &ignorecase = 0
    1              0.000001   try
    2              0.000003     for r in a:context.candidates
    1              0.000007       let pos = match(r.word, next_keyword)
    1              0.000002       if pos >= 0
    1              0.000002         if !has_key(r, 'abbr')
    1              0.000003           let r.abbr = r.word
    1              0.000001         endif
                            
    1              0.000003         let r.word = r.word[: pos-1]
    1              0.000001       endif
    1              0.000001     endfor
    1              0.000001   finally
    1              0.000002     let &ignorecase = ignorecase_save
    1              0.000001   endtry
                            
    1              0.000002   return a:context.candidates

FUNCTION  474()
Called 2 times
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
    2              0.000005   if g:neocomplcache_max_keyword_width < 0
                                return a:context.candidates
                              endif
                            
   16              0.000020   for candidate in a:context.candidates
   14              0.000054     let abbr = get(candidate, 'abbr', candidate.word)
   14              0.000035     if len(abbr) > g:neocomplcache_max_keyword_width
                                  let len = neocomplcache#util#wcswidth(abbr)
                            
                                  if len > g:neocomplcache_max_keyword_width
                                    let candidate.abbr = neocomplcache#util#truncate_smart( abbr, g:neocomplcache_max_keyword_width, g:neocomplcache_max_keyword_width/2, '..')
                                  endif
                                endif
   14              0.000010   endfor
                            
    2              0.000004   return a:context.candidates

FUNCTION  462()
Called 22 times
Total time:   0.016963
 Self time:   0.001346

count  total (s)   self (s)
   22              0.000198   if !has_key(s:async_tags_list, bufnr('%')) && !has_key(s:tags_list, bufnr('%'))
                                call neocomplcache#sources#tags_complete#caching_tags(0)
                              endif
                            
   22   0.012532   0.000094   if neocomplcache#within_comment()
                                return []
                              endif
                            
   22   0.001001   0.000334   call neocomplcache#cache#check_cache( 'tags_cache', bufnr('%'), s:async_tags_list, s:tags_list)
                            
   22              0.000083   if !has_key(s:tags_list, bufnr('%'))
                                return []
                              endif
   22   0.000443   0.000193   let keyword_list = neocomplcache#dictionary_filter( s:tags_list[bufnr('%')], a:complete_str)
                            
   22   0.002392   0.000130   return neocomplcache#keyword_filter(keyword_list, a:complete_str)

FUNCTION  neocomplcache#get_temporary_directory()
Called 24 times
Total time:   0.001389
 Self time:   0.000571

count  total (s)   self (s)
   24   0.001156   0.000338   let directory = neocomplcache#util#substitute_path_separator( neocomplcache#util#expand(g:neocomplcache_temporary_dir))
   24              0.000099   if !isdirectory(directory) && !neocomplcache#util#is_sudo()
                                call mkdir(directory, 'p')
                              endif
                            
   24              0.000030   return directory

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 138 times
Total time:   0.016011
 Self time:   0.002082

count  total (s)   self (s)
  138   0.014860   0.000931   let errors = SyntasticStatuslineFlag()
  138              0.000360   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
  138              0.000142   return ''

FUNCTION  <SNR>64_generate_names()
Called 142 times
Total time:   0.167454
 Self time:   0.167454

count  total (s)   self (s)
  142              0.000362   let names = []
  142              0.000237   let i = 1
  142              0.000462   let last_buffer = bufnr('$')
  142              0.000527   let current_buffer = bufnr('%')
 2272              0.003687   while i <= last_buffer
 2130              0.006654     if bufexists(i) && buflisted(i)
 1136              0.002117       let modified = ' '
 1136              0.007811       if getbufvar(i, '&mod')
  120              0.000334         let modified = g:bufferline_modified
  120              0.000110       endif
 1136              0.006301       let fname = fnamemodify(bufname(i), g:bufferline_fname_mod)
 1136              0.010998       let fname = substitute(fname, "%", "%%", "g")
                            
 1136              0.002057       let skip = 0
 2272              0.003736       for ex in g:bufferline_excludes
 1136              0.007187         if match(fname, ex) > -1
                                      let skip = 1
                                      break
                                    endif
 1136              0.001378       endfor
                            
 1136              0.001295       if !skip
 1136              0.002111         let name = ''
 1136              0.004050         if g:bufferline_show_bufnr != 0 && g:bufferline_status_info.count >= g:bufferline_show_bufnr
 1136              0.003379           let name =  i . ':'
 1136              0.001072         endif
 1136              0.003793         let name .= fname . modified
                            
 1136              0.001873         if current_buffer == i
  142              0.000662           let name = g:bufferline_active_buffer_left . name . g:bufferline_active_buffer_right
  142              0.000558           let g:bufferline_status_info.current = name
  142              0.000198         else
  994              0.004141           let name = g:bufferline_separator . name . g:bufferline_separator
  994              0.000929         endif
                            
 1136              0.006347         call add(names, [i, name])
 1136              0.001035       endif
 1136              0.000887     endif
 2130              0.003814     let i += 1
 2130              0.002875   endwhile
                            
  142              0.000331   if len(names) > 1
  142              0.000255     if g:bufferline_rotate == 1
                                  call bufferline#algos#fixed_position#modify(names)
                                endif
  142              0.000119   endif
                            
  142              0.000242   return names

FUNCTION  InsertEnter()
Called 2 times
Total time:   0.000413
 Self time:   0.000078

count  total (s)   self (s)
    2              0.000034   let g:insertmode = 1
    2   0.000369   0.000034   call UpdateMode()

FUNCTION  neocomplcache#complete#manual_complete()
Called 25 times
Total time:   0.905238
 Self time:   0.002713

count  total (s)   self (s)
   25   0.000408   0.000141   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
   25              0.000034   if a:findstart
   23   0.000648   0.000110     let cur_text = neocomplcache#get_cur_text()
   23   0.015893   0.000273     if !neocomplcache#is_enabled() || neocomplcache#helper#is_omni_complete(cur_text)
                                  call neocomplcache#helper#clear_result()
                                  let &l:completefunc = 'neocomplcache#complete#manual_complete'
                            
                                  return (neocomplcache#is_prefetch() || g:neocomplcache_enable_insert_char_pre) ? -1 : -3
                                endif
                            
                                " Get complete_pos.
   23   0.001559   0.000371     if neocomplcache#is_prefetch() && !empty(neocomplcache.complete_results)
                                  " Use prefetch results.
                                else
   23   0.873437   0.000214       let neocomplcache.complete_results = neocomplcache#complete#_get_results(cur_text)
   23              0.000020     endif
   23   0.000386   0.000260     let complete_pos = neocomplcache#complete#_get_complete_pos(neocomplcache.complete_results)
                            
   23              0.000034     if complete_pos < 0
   21   0.000649   0.000125       call neocomplcache#helper#clear_result()
                            
   21   0.000272   0.000106       let neocomplcache = neocomplcache#get_current_neocomplcache()
   21   0.001277   0.000195       let complete_pos = (neocomplcache#is_prefetch() || g:neocomplcache_enable_insert_char_pre || neocomplcache#get_current_neocomplcache().skipped) ?  -1 : -3
   21              0.000080       let neocomplcache.skipped = 0
   21              0.000016     endif
                            
   23              0.000031     return complete_pos
                              else
    2   0.000043   0.000014     let complete_pos = neocomplcache#complete#_get_complete_pos( neocomplcache.complete_results)
    2   0.009824   0.000062     let neocomplcache.candidates = neocomplcache#complete#_get_words( neocomplcache.complete_results, complete_pos, a:base)
    2              0.000006     let neocomplcache.complete_str = a:base
                            
    2              0.000006     if v:version > 703 || v:version == 703 && has('patch418')
    2              0.000007       let dict = { 'words' : neocomplcache.candidates }
                            
    2              0.000012       if (g:neocomplcache_enable_cursor_hold_i      || v:version > 703 || v:version == 703 && has('patch561')) && len(a:base) < g:neocomplcache_auto_completion_start_length
                                    " Note: If Vim is less than 7.3.561, it have broken register "." problem.
                                    let dict.refresh = 'always'
                                  endif
    2              0.000002       return dict
                                else
                                  return neocomplcache.candidates
                                endif
                              endif

FUNCTION  <SNR>253_set_complete_results_pos()
Called 46 times
Total time:   0.003988
 Self time:   0.003766

count  total (s)   self (s)
                              " Try omnifunc completion. "{{{
   46              0.000106   let complete_results = {}
   92              0.000235   for [omnifunc, pattern] in a:funcs
   46   0.001456   0.001234     if neocomplcache#is_auto_complete() && a:cur_text !~ '\%(' . pattern . '\m\)$'
   46              0.000085       continue
                                endif
                            
                                " Save pos.
                                let pos = getpos('.')
                            
                                try
                                  let complete_pos = call(omnifunc, [1, ''])
                                catch
                                  call neocomplcache#print_error( 'Error occurred calling omnifunction: ' . omnifunc)
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  let complete_pos = -1
                                finally
                                  if getpos('.') != pos
                                    call setpos('.', pos)
                                  endif
                                endtry
                            
                                if complete_pos < 0
                                  continue
                                endif
                            
                                let complete_str = a:cur_text[complete_pos :]
                            
                                let complete_results[omnifunc] = { 'candidates' : [], 'complete_pos' : complete_pos, 'complete_str' : complete_str, 'omnifunc' : omnifunc,}
                              endfor
                              "}}}
                            
   46              0.000060   return complete_results

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 5 times
Total time:   0.000474
 Self time:   0.000207

count  total (s)   self (s)
    5              0.000031   if getbufvar(a:bufnr, '&modified')
    4              0.000053     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000003   else
    1              0.000011     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000000   endif
                            
    5              0.000010   if !empty(colors)
    5   0.000317   0.000050     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    5              0.000003   endif

FUNCTION  neocomplcache#get_current_neocomplcache()
Called 2654 times
Total time:   0.022980
 Self time:   0.022980

count  total (s)   self (s)
 2654              0.007860   if !exists('b:neocomplcache')
                                call neocomplcache#init#_current_neocomplcache()
                              endif
                            
 2654              0.003785   return b:neocomplcache

FUNCTION  <SNR>259_keyword_filter()
Called 22 times
Total time:   0.030062
 Self time:   0.001432

count  total (s)   self (s)
                              " Uniq by real_name.
   22              0.000064   let dict = {}
                            
                              " Use default filter.
   22   0.028784   0.000643   let list = neocomplcache#keyword_filter( values(a:snippets), a:cur_keyword_str)
                            
                              " Add cur_keyword_str snippet.
   22              0.000100   if has_key(a:snippets, a:cur_keyword_str)
                                call add(list, a:snippets[a:cur_keyword_str])
                              endif
                            
   22   0.000665   0.000176   for snippet in neocomplcache#dup_filter(list)
                                if !has_key(dict, snippet.real_name) || len(dict[snippet.real_name].word) > len(snippet.word)
                                  let dict[snippet.real_name] = snippet
                                endif
                              endfor
                            
   22              0.000041   return values(dict)

FUNCTION  airline#extensions#branch#get_head()
Called 138 times
Total time:   0.006126
 Self time:   0.004172

count  total (s)   self (s)
  138   0.002824   0.000870   let head = airline#extensions#branch#head()
  138              0.001032   let empty_message = get(g:, 'airline#extensions#branch#empty_message', get(g:, 'airline_branch_empty_message', ''))
  138              0.000769   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  138              0.001153   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  fugitive#head()
Called 2 times
Total time:   0.000517
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000007   if !exists('b:git_dir')
                                return ''
                              endif
                            
    2   0.000504   0.000028   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  neocomplcache#complete#_get_words()
Called 2 times
Total time:   0.009762
 Self time:   0.001032

count  total (s)   self (s)
    2   0.000271   0.000015   let frequencies = neocomplcache#variables#get_frequencies()
    2              0.000010   if exists('*neocomplcache#sources#buffer_complete#get_frequencies')
    2   0.000146   0.000127     let frequencies = extend(copy( neocomplcache#sources#buffer_complete#get_frequencies()), frequencies)
    2              0.000002   endif
                            
                              " Append prefix.
    2              0.000004   let candidates = []
    2              0.000004   let len_words = 0
    4              0.000027   for source in sort(filter(copy(a:sources), '!empty(v:val.neocomplcache__context.candidates)'),  's:compare_source_rank')
    2              0.000004     let context = source.neocomplcache__context
    2              0.000051     let words = type(context.candidates[0]) == type('') ? map(copy(context.candidates), "{'word': v:val}") : deepcopy(context.candidates)
    2              0.000006     let context.candidates = words
                            
    2   0.000171   0.000020     call neocomplcache#helper#call_hook( source, 'on_post_filter', {})
                            
    2              0.000004     if context.complete_pos > a:complete_pos
                                  let prefix = a:complete_str[: context.complete_pos                            - a:complete_pos - 1]
                            
                                  for candidate in words
                                    let candidate.word = prefix . candidate.word
                                  endfor
                                endif
                            
   16              0.000017     for candidate in words
   14              0.000047       if !has_key(candidate, 'menu') && has_key(source, 'mark')
                                    " Set default menu.
   14              0.000029         let candidate.menu = source.mark
   14              0.000010       endif
   14              0.000031       if has_key(frequencies, candidate.word)
    1              0.000003         let candidate.rank = frequencies[candidate.word]
    1              0.000001       endif
   14              0.000019     endfor
                            
    2   0.000744   0.000025     let words = neocomplcache#helper#call_filters( source.sorters, source, {})
                            
    2              0.000003     if source.max_candidates > 0
                                  let words = words[: len(source.max_candidates)-1]
                                endif
                            
    2   0.007109   0.000020     let words = neocomplcache#helper#call_filters( source.converters, source, {})
                            
    2              0.000006     let candidates += words
    2              0.000006     let len_words += len(words)
                            
    2              0.000006     if g:neocomplcache_max_list > 0 && len_words > g:neocomplcache_max_list
                                  break
                                endif
                            
    2   0.000280   0.000020     if neocomplcache#complete_check()
                                  return []
                                endif
    2              0.000002   endfor
                            
    2              0.000002   if g:neocomplcache_max_list > 0
    2              0.000008     let candidates = candidates[: g:neocomplcache_max_list]
    2              0.000001   endif
                            
                              " Check dup and set icase.
    2   0.000067   0.000030   let icase = g:neocomplcache_enable_ignore_case &&!(g:neocomplcache_enable_smart_case && a:complete_str =~ '\u') && !neocomplcache#is_text_mode()
   16              0.000019   for candidate in candidates
   14              0.000035     if has_key(candidate, 'kind') && candidate.kind == ''
                                  " Remove kind key.
                                  call remove(candidate, 'kind')
                                endif
                            
   14              0.000068     let candidate.icase = icase
   14              0.000017   endfor
                            
    2   0.000206   0.000007   if neocomplcache#complete_check()
                                return []
                              endif
                            
    2              0.000002   return candidates

FUNCTION  <SNR>246_initialize_source()
Called 24 times
Total time:   0.007839
 Self time:   0.001554

count  total (s)   self (s)
   24              0.000147   let path = fnamemodify(bufname(a:srcname), ':p')
   24              0.000083   let filename = fnamemodify(path, ':t')
   24              0.000047   if filename == ''
   24              0.000047     let filename = '[No Name]'
   24              0.000070     let path .= '/[No Name]'
   24              0.000019   endif
                            
   24              0.000079   let ft = getbufvar(a:srcname, '&filetype')
   24              0.000034   if ft == ''
   24              0.000039     let ft = 'nothing'
   24              0.000018   endif
                            
   24              0.000094   let buflines = getbufline(a:srcname, 1, '$')
   24   0.002729   0.000163   let keyword_pattern = neocomplcache#get_keyword_pattern(ft)
                            
   24   0.004293   0.000574   let s:buffer_sources[a:srcname] = { 'keyword_cache' : {}, 'frequencies' : {}, 'name' : filename, 'filetype' : ft, 'keyword_pattern' : keyword_pattern, 'end_line' : len(buflines), 'accessed_time' : 0, 'cached_time' : 0, 'path' : path, 'loaded_cache' : 0, 'cache_name' : neocomplcache#cache#encode_name(   'buffer_cache', path),}

FUNCTION  airline#extensions#hunks#get_hunks()
Called 138 times
Total time:   0.019151
 Self time:   0.011354

count  total (s)   self (s)
  138              0.000553   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
  138   0.008875   0.001078   let hunks = s:get_hunks()
  138              0.000292   let string = ''
  138              0.000294   if !empty(hunks)
  552              0.001248     for i in [0, 1, 2]
  414              0.001089       if s:non_zero_only == 0 || hunks[i] > 0
  414              0.003466         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  414              0.000431       endif
  414              0.000468     endfor
  138              0.000137   endif
  138              0.000244   return string

FUNCTION  neocomplcache#complete#_set_results_words()
Called 23 times
Total time:   0.710705
 Self time:   0.015471

count  total (s)   self (s)
                              " Try source completion.
  155              0.000305   for source in a:sources
  132   0.018351   0.002649     if neocomplcache#complete_check()
                                  return
                                endif
                            
                                " Save options.
  132              0.000294     let ignorecase_save = &ignorecase
                            
  132              0.000371     let context = source.neocomplcache__context
                            
  132   0.003129   0.000609     if neocomplcache#is_text_mode()
                                  let &ignorecase = 1
                                elseif g:neocomplcache_enable_smart_case && context.complete_str =~ '\u'
                                  let &ignorecase = 0
                                else
  132              0.000458       let &ignorecase = g:neocomplcache_enable_ignore_case
  132              0.000092     endif
                            
  132              0.000577     let pos = winsaveview()
                            
  132              0.000334     try
  132   0.679190   0.002178       let context.candidates = has_key(source, 'get_keyword_list') ? source.get_keyword_list(context.complete_str) :  has_key(source, 'get_complete_words') ? source.get_complete_words(   context.complete_pos, context.complete_str) : source.gather_candidates(context)
  132              0.000167     catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error( 'Source name is ' . source.name)
                                  call neocomplcache#print_error( 'Error occurred in source''s gather_candidates()!')
                                  return
                                finally
  132              0.000792       if winsaveview() != pos
                                    call winrestview(pos)
                                  endif
  132              0.000167     endtry
                            
  132              0.000215     if g:neocomplcache_enable_debug
                                  echomsg source.name
                                endif
                            
  132              0.000551     let &ignorecase = ignorecase_save
  132              0.000137   endfor

FUNCTION  <SNR>228_GetNearbyTag()
Called 25 times
Total time:   0.010665
 Self time:   0.010290

count  total (s)   self (s)
   25              0.000045     if s:nearby_disabled
                                    return {}
                                endif
                            
   25   0.000324   0.000205     let fileinfo = s:known_files.getCurrent(a:forcecurrent)
   25              0.000060     if empty(fileinfo)
                                    return {}
                                endif
                            
   25              0.000060     let typeinfo = fileinfo.typeinfo
   25              0.000030     if a:0 > 0
                                    let curline = a:1
                                else
   25              0.000071         let curline = line('.')
   25              0.000019     endif
   25              0.000046     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
  792              0.000956     for line in range(curline, 1, -1)
  769              0.001806         if has_key(fileinfo.fline, line)
   42              0.000118             let curtag = fileinfo.fline[line]
   42   0.000546   0.000290             if a:all || typeinfo.getKind(curtag.fields.kind).stl
    2              0.000002                 let tag = curtag
    2              0.000002                 break
                                        endif
   40              0.000033         endif
  767              0.000631     endfor
                            
   25              0.000031     return tag

FUNCTION  <SNR>143_get_syn()
Called 468 times
Total time:   0.024155
 Self time:   0.024155

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
  468              0.002436   let mode = has('gui_running') ? 'gui' : 'cterm'
  468              0.010321   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
  468              0.001222   if empty(color) || color == -1
  126              0.002789     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
  126              0.000119   endif
  468              0.001073   if empty(color) || color == -1
   63              0.000234     if has('gui_running')
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
   63              0.000156       let color = a:what ==# 'fg' ? 0 : 1
   63              0.000046     endif
   63              0.000043   endif
  468              0.000562   return color

FUNCTION  neocomplcache#context_filetype#set()
Called 46 times
Total time:   0.013250
 Self time:   0.003683

count  total (s)   self (s)
   46   0.000652   0.000248   let old_filetype = neocomplcache#get_current_neocomplcache().filetype
   46              0.000084   if old_filetype == ''
   46              0.000111     let old_filetype = &filetype
   46              0.000031   endif
   46              0.000071   if old_filetype == ''
                                let old_filetype = 'nothing'
                              endif
                            
   46   0.000598   0.000234   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
   46              0.000118   let dup_check = {}
   92              0.000136   while 1
   92   0.009576   0.000777     let new_filetype = neocomplcache#context_filetype#get(old_filetype)
                            
                                " Check filetype root.
   92              0.000385     if get(dup_check, old_filetype, '') ==# new_filetype
   46              0.000130       let neocomplcache.context_filetype = old_filetype
   46              0.000052       break
                                endif
                            
                                " Save old -> new filetype graph.
   46              0.000176     let dup_check[old_filetype] = new_filetype
   46              0.000096     let old_filetype = new_filetype
   46              0.000062   endwhile
                            
   46              0.000077   return neocomplcache.context_filetype

FUNCTION  455()
Called 46 times
Total time:   0.046740
 Self time:   0.002309

count  total (s)   self (s)
   46   0.026033   0.000293   let syn_name = neocomplcache#helper#get_syn_name(1)
   46              0.000184   if syn_name ==# 'Comment' || syn_name ==# 'String'
                                " Skip omni_complete in string literal.
                                return -1
                              endif
                            
   46   0.002285   0.000401   let filetype = neocomplcache#get_context_filetype()
   46   0.017319   0.000751   let s:complete_results = s:set_complete_results_pos( s:get_omni_funcs(filetype), a:cur_text)
                            
   46   0.000616   0.000377   return s:get_complete_pos(s:complete_results)

FUNCTION  SyntasticStatuslineFlag()
Called 138 times
Total time:   0.013929
 Self time:   0.001497

count  total (s)   self (s)
  138   0.013784   0.001352     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>214_PreviewCSSColor()
Called 69 times
Total time:   0.020076
 Self time:   0.020076

count  total (s)   self (s)
                              "if !exists('&w:colorDictRegExp')
                              "endif
                            
   69              0.000145   let line=a:str "getline(a:w)
   69              0.000551   let colorexps = { 'hex'  : '#[0-9A-Fa-f]\{3\}\>\|#[0-9A-Fa-f]\{6\}\>', 'rgba' : 'rgba\?(\s*\(\d\{1,3}%\?\)\s*,\s*\(\d\{1,3}%\?\)\s*,\s*\(\d\{1,3}%\?\)\s*\%(,[^)]*\)\?)', 'hsla' : 'hsla\?(\s*\(\d\{1,3}%\?\)\s*,\s*\(\d\{1,3}%\?\)\s*,\s*\(\d\{1,3}%\?\)\s*\%(,[^)]*\)\?)' }
                                "\ 'color': w:colorDictRegExp
                            
                              "let foundcolor=''
                            
  276              0.000520   for exp in keys(colorexps)
  207              0.000352       let place=0
                            
  207              0.000494       if exists("foundcolor")
  138              0.000166           unlet foundcolor
  138              0.000118       endif
                            
  207              0.000169       while 1
  207              0.000472           if exp=='rgba'||exp=='hsla'
  138              0.002103               let foundcolor = matchlist(a:str, colorexps[exp], place)
  138              0.000154           else
   69              0.000746               let foundcolor = matchstr(a:str, colorexps[exp], place)
   69              0.000073           endif
                            
  207              0.002205           let place = matchend(a:str, colorexps[exp], place)
                            
  207              0.000392           if empty(foundcolor)
  207              0.000210               break
                                      endif
                            
                                      if exp=='hex'
                                          let part = foundcolor.'\>'
                                      else
                                          let part = foundcolor[0]
                                      endif
                            
                                      if exp=='hex'
                                          if len(foundcolor) == 4
                                              let foundcolor = substitute(foundcolor, '[[:xdigit:]]', '&&', 'g')
                                          endif
                                          call s:MatchColorValue(strpart(foundcolor, 1), part)
                                      elseif exp=='rgba'
                                          "TODO get rid of duplicated variables
                                          call s:MatchColorValue(s:HexForRGBValue(foundcolor[1], foundcolor[2], foundcolor[3]), part)
                                      elseif exp=='hsla'
                                          call s:MatchColorValue(s:HexForHSLValue(foundcolor[1], foundcolor[2], foundcolor[3]), part)
                                      endif
                                  endwhile
  207              0.000215   endfor
                            

FUNCTION  airline#util#prepend()
Called 138 times
Total time:   0.001484
 Self time:   0.001484

count  total (s)   self (s)
  138              0.000397   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  138              0.000558   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  neocomplcache#helper#clear_result()
Called 21 times
Total time:   0.000524
 Self time:   0.000349

count  total (s)   self (s)
   21   0.000283   0.000108   let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
   21              0.000049   let neocomplcache.complete_str = ''
   21              0.000057   let neocomplcache.candidates = []
   21              0.000043   let neocomplcache.complete_results = []
   21              0.000040   let neocomplcache.complete_pos = -1

FUNCTION  neocomplcache#check_match_filter()
Called 132 times
Total time:   0.022501
 Self time:   0.001878

count  total (s)   self (s)
  132   0.022408   0.001785   return neocomplcache#keyword_escape(a:complete_str) =~ '[^\\]\*\|\\+'

FUNCTION  <SNR>240_strchars()
Called 274 times
Total time:   0.000856
 Self time:   0.000856

count  total (s)   self (s)
  274              0.000713     return strchars(a:str)

FUNCTION  <SNR>252_get_member_pattern()
Called 46 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
   46              0.000287   return has_key(g:neocomplcache_member_patterns, a:filetype) ? g:neocomplcache_member_patterns[a:filetype] : g:neocomplcache_member_patterns['default']

FUNCTION  neocomplcache#is_locked()
Called 250 times
Total time:   0.008958
 Self time:   0.005251

count  total (s)   self (s)
  250              0.001306   let bufnr = a:0 > 0 ? a:1 : bufnr('%')
  250   0.007334   0.003627   return !neocomplcache#is_enabled() || &paste || g:neocomplcache_disable_auto_complete || neocomplcache#get_current_neocomplcache().lock || (g:neocomplcache_lock_buffer_name_pattern != '' &&   bufname(bufnr) =~ g:neocomplcache_lock_buffer_name_pattern) || &l:omnifunc ==# 'fuf#onComplete'

FUNCTION  neocomplcache#is_eskk_enabled()
Called 69 times
Total time:   0.000345
 Self time:   0.000345

count  total (s)   self (s)
   69              0.000313   return exists('*eskk#is_enabled') && eskk#is_enabled()

FUNCTION  <SNR>238_substitute_path_separator()
Called 24 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
   24              0.000102   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   25   0.905495   0.000257  neocomplcache#complete#auto_complete()
   25   0.905238   0.002713  neocomplcache#complete#manual_complete()
   23   0.873223   0.001715  neocomplcache#complete#_get_results()
   23   0.710705   0.015471  neocomplcache#complete#_set_results_words()
  110   0.514068   0.000912  neocomplcache#dictionary_filter()
  110   0.513156   0.005391  neocomplcache#filters#dictionary_filter()
   22   0.453971   0.001483  459()
  178   0.452676   0.001683  neocomplcache#keyword_filter()
  178   0.450993   0.402037  neocomplcache#filters#keyword_filter()
   46   0.321242   0.045087  neocomplcache#complete#_set_results_pos()
   23   0.189735   0.003982  neocomplcache#handler#_do_auto_complete()
  142   0.183639   0.016185  bufferline#get_echo_string()
  138   0.183267   0.004013  bufferline#refresh_status()
  142   0.167454             <SNR>64_generate_names()
  138   0.119088   0.016558  airline#check_mode()
   22   0.117098   0.003276  434()
   46   0.102674   0.015775  468()
   66   0.102641             neocomplcache#unpack_dictionary()
    5   0.102056   0.024133  airline#highlighter#highlight()
   68   0.092516   0.070862  neosnippet#helpers#get_snippets()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  178   0.450993   0.402037  neocomplcache#filters#keyword_filter()
  142              0.167454  <SNR>64_generate_names()
   66              0.102641  neocomplcache#unpack_dictionary()
  138              0.078017  neocomplcache#helper#get_syn_name()
   68   0.092516   0.070862  neosnippet#helpers#get_snippets()
   46   0.321242   0.045087  neocomplcache#complete#_set_results_pos()
  330   0.045290   0.031991  neocomplcache#helper#keyword_escape()
    4   0.029183   0.029134  <SNR>246_caching_current_buffer()
  602              0.029099  airline#highlighter#exec()
  130              0.028135  <SNR>119_Highlight_Matching_Pair()
  310              0.025897  neocomplcache#helper#unite_patterns()
  468              0.024155  <SNR>143_get_syn()
    5   0.102056   0.024133  airline#highlighter#highlight()
 2654              0.022980  neocomplcache#get_current_neocomplcache()
   69              0.020076  <SNR>214_PreviewCSSColor()
  810   0.030575   0.017749  neocomplcache#get_context_filetype()
   22   0.038619   0.017715  <SNR>246_check_source()
  138   0.119088   0.016558  airline#check_mode()
  142   0.183639   0.016185  bufferline#get_echo_string()
   46   0.102674   0.015775  468()

